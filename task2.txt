----------------------------------current task------------------------------------
import {
  Decal,
  Environment,
  Html,
  OrbitControls,
  Text,
} from "@react-three/drei";
import { Canvas, useFrame, useLoader, useThree } from "@react-three/fiber";
import React, { useState, useEffect, useRef, useMemo, Suspense } from "react";
import { useSpring } from "@react-spring/three";
import { TextureLoader, CanvasTexture, LinearFilter } from "three";
import * as THREE from "three";

import { Leva, useControls } from "leva";
import Loader from "./TaskSix/Loader";
import { Sphere } from "./Sphere";

const degToRad = (degrees) => degrees * (Math.PI / 180);

const createTextTexture = (
  text,
  heading,
  buttonText,
  headingColor,
  textColor,
  buttonColor
) => {
  const canvas = document.createElement("canvas");
  canvas.width = 4300; // Adjust this to control the resolution
  canvas.height = 2080; // Adjust this to control the resolution
  const context = canvas.getContext("2d");

  // Background
  context.fillStyle = "white";
  context.fillRect(0, 0, canvas.width, canvas.height);

  // Heading
  context.font = "bold 150px Arial";
  context.fillStyle = headingColor;
  context.textAlign = "center";
  context.textBaseline = "middle";
  context.lineJoin = "round";
  context.miterLimit = 2;
  context.fillText(heading, canvas.width / 2, 200);

  // Button
  const buttonWidth = 800; // Adjusted width
  const buttonHeight = 200; // Adjusted height
  const buttonX = canvas.width / 2 - buttonWidth / 2;
  const buttonY = 400; // Adjusted y-position

  context.fillStyle = buttonColor;
  context.fillRect(buttonX, buttonY, buttonWidth, buttonHeight);
  context.font = "bold 80px Arial"; // Larger font size
  context.fillStyle = textColor;
  context.fillText(buttonText, canvas.width / 2, buttonY + buttonHeight / 2);

  // Paragraph
  context.font = "50px Arial"; // Larger font size
  context.fillStyle = textColor;
  context.textAlign = "center";

  const words = text.split(" ");
  let line = "";
  let y = buttonY + buttonHeight + 100; // Adjusted y-position
  // let x = buttonX + buttonHeight + 0; // Adjusted y-position
  const lineHeight = 100; // Increased line height

  words.forEach((word) => {
    const testLine = `${line}${word} `;
    const metrics = context.measureText(testLine);
    const testWidth = metrics.width;
    if (testWidth > canvas.width - 40 && line !== "") {
      context.fillText(line, canvas.width / 2, y);
      line = `${word} `;
      y += lineHeight;
    } else {
      line = testLine;
    }
  });
  context.fillText(line, canvas.width / 2, y);

  const texture = new CanvasTexture(canvas);
  texture.anisotropy = 16; // Increase anisotropy for better quality at an angle
  texture.minFilter = LinearFilter; // Use linear filter for smoother appearance
  texture.magFilter = LinearFilter; // Use linear filter for smoother appearance
  texture.generateMipmaps = false; // Disable mipmaps if text appears blurry

  return texture;
};

const BoxGeometry = ({
  text,
  mobile,
  heading,
  buttonText,
  headingColor,
  buttonColor,
  textColor = "black",
  color = "orange",
  position,
  rotateX,
  rotateY,
}) => {
  const texture = useMemo(() => {
    return createTextTexture(
      text,
      heading,
      buttonText,
      headingColor,
      textColor,
      buttonColor
    );
  }, [text, heading, buttonText, headingColor, textColor, buttonColor]);

  const SafariRef = useRef();

  // const [safariHovered, setSafariHovered] = useState(false);
  const [safariClicked, setSafariClicked] = useState(false);

  const Safaritexture = useLoader(THREE.TextureLoader, "/images/safaris.png");

  useFrame(() => {
    const targetScales = {
      Safari: safariClicked
        ? new THREE.Vector3(1.2, 1.2, 1)
        : new THREE.Vector3(1, 1, 1),
    };

    SafariRef.current.scale.lerp(targetScales.Safari, 0.1);
  });

  useEffect(() => {
    const timeoutDuration = 1 * 1000; // 2 minutes in milliseconds

    // Set timeout for photoClicked
    if (safariClicked) {
      const timer = setTimeout(() => {
        setSafariClicked(false);
      }, timeoutDuration);
      return () => clearTimeout(timer);
    }
  }, [safariClicked]);

  return (
    <mesh
      position={position}
      rotation={[rotateX, rotateY, 0]}
      scale={mobile ? 0.7 : 1}
    >
      <sphereGeometry args={[1, 63, 63]} />
      <meshStandardMaterial
        metalness={0}
        roughness={0}
        opacity={1}
        color={color}
        map={texture}
      />

      <Decal
        depthWrite
        polygonOffset
        ref={SafariRef}
        polygonOffsetFactor={-4}
        // onPointerOver={() => setSafariHovered(true)}
        // onPointerOut={() => setSafariHovered(false)}
        onClick={() => setSafariClicked(true)}
        position={[0, 0.601, 0.8]}
        rotation={[0, 0, 0]}
        scale={new THREE.Vector3(0.08, 0.08, 0.08)}
        map={Safaritexture}
      />
    </mesh>
  );
};

const CameraController = ({ cameraPosition }) => {
  const { camera } = useThree();
  const { position } = useSpring({ position: cameraPosition });

  useEffect(() => {
    camera.position.set(...position.get());
    camera.updateProjectionMatrix();
  }, [position, camera]);

  return null;
};

const Controls = ({
  isLimitedZoom,
  currentDistanceRef,
  initialDistance,
  zoomLocked,
}) => {
  const controlsRef = useRef();
  const { camera } = useThree();
  const [initialPositionSet, setInitialPositionSet] = useState(false);
  const zoomLimitsSetRef = useRef(false);

  useEffect(() => {
    if (!initialPositionSet) {
      camera.position.set(0, 0, initialDistance);
      setInitialPositionSet(true);
    }
  }, [camera, initialDistance, initialPositionSet]);

  useEffect(() => {
    if (controlsRef.current) {
      controlsRef.current.enabled = !zoomLocked;
      controlsRef.current.update();
    }
  }, [zoomLocked]);

  useEffect(() => {
    if (controlsRef.current) {
      const currentDistance = currentDistanceRef.current;

      if (isLimitedZoom && !zoomLimitsSetRef.current) {
        if (currentDistance <= 5) {
          controlsRef.current.minDistance = currentDistance - 1;
          controlsRef.current.maxDistance = currentDistance + 1.1;
        } else {
          controlsRef.current.minDistance = currentDistance - 5;
          controlsRef.current.maxDistance = currentDistance + 5;
        }
        zoomLimitsSetRef.current = true;
      } else if (!isLimitedZoom) {
        controlsRef.current.minDistance = 2;
        controlsRef.current.maxDistance = 45;
        zoomLimitsSetRef.current = false;
      }

      controlsRef.current.update();
    }
  }, [isLimitedZoom]);

  useFrame(() => {
    if (controlsRef.current) {
      const currentDistance = controlsRef.current.object.position.distanceTo(
        controlsRef.current.target
      );
      currentDistanceRef.current = currentDistance;
    }
  });

  return <OrbitControls ref={controlsRef} enableZoom />;
};

const CombinedController = ({ mode }) => {
  const { camera } = useThree();
  const meshRef = useRef();
  const horizontalAngleRef = useRef(0);
  const verticalAngleRef = useRef(0);
  const scrollXRef = useRef(0);
  const scrollYRef = useRef(0);
  const [lastTouch, setLastTouch] = useState({ x: 0, y: 0 });

  useEffect(() => {
    const handleScroll = (event) => {
      if (mode === "camera") {
        horizontalAngleRef.current += event.deltaX * 0.01;
        verticalAngleRef.current += event.deltaY * 0.01;
      } else if (mode === "object") {
        scrollXRef.current += event.deltaX * 0.01;
        scrollYRef.current += event.deltaY * 0.01;
      }
    };

    const handleTouchStart = (event) => {
      const touch = event.touches[0];
      setLastTouch({ x: touch.clientX, y: touch.clientY });
    };

    const handleTouchMove = (event) => {
      const touch = event.touches[0];
      const deltaX = touch.clientX - lastTouch.x;
      const deltaY = touch.clientY - lastTouch.y;
      if (mode === "camera") {
        horizontalAngleRef.current += deltaX * 0.01;
        verticalAngleRef.current += deltaY * 0.01;
      } else if (mode === "object") {
        scrollXRef.current += deltaX * 0.01;
        scrollYRef.current += deltaY * 0.01;
      }
      setLastTouch({ x: touch.clientX, y: touch.clientY });
    };

    window.addEventListener("wheel", handleScroll, { passive: true });
    window.addEventListener("touchstart", handleTouchStart, { passive: true });
    window.addEventListener("touchmove", handleTouchMove, { passive: true });

    return () => {
      window.removeEventListener("wheel", handleScroll);
      window.removeEventListener("touchstart", handleTouchStart);
      window.removeEventListener("touchmove", handleTouchMove);
    };
  }, [mode, lastTouch]);

  useFrame(() => {
    if (mode === "camera") {
      camera.position.x = Math.cos(horizontalAngleRef.current) * 3;
      camera.position.y = Math.sin(verticalAngleRef.current) * 3;
      camera.lookAt(0, 0, 0);
    } else if (mode === "object" && meshRef.current) {
      meshRef.current.rotation.y = scrollXRef.current;
      meshRef.current.rotation.x = scrollYRef.current;
    }
  });
  return null
};

const GGG = () => {
  const [cameraPosition, setCameraPosition] = useState([0, 0, 3]);
  const [buttonText, setButtonText] = useState("Click Me");
  const [heading, setHeading] = useState("Global Text");
  const [text, setText] = useState(
    "  Possimus aperiam hic sapiente, quam doloribus eos assumenda soluta iusto fugit perspiciatis quo, vitae vel sed. Harum eveniet sequi ut laudantium iure. Lorem ipsum itae vel sed. Harum eveniet sequi ut laudantium iure"
  );
  const [rotateX, setRotateX] = useState(0);
  const [rotateY, setRotateY] = useState(0);
  const [environmentActive, setEnvironmentActive] = useState(true);
  const [mobile, setMobile] = useState(false);
  const [zoomLocked, setZoomLocked] = useState(false);
  const [isLimitedZoom, setIsLimitedZoom] = useState(false);
  const currentDistanceRef = useRef(3);
  const initialDistance = 3;
  const [model, setModel] = useState(false);
  const [join, setJoin] = useState(false);
  const [scrollEnabled, setScrollEnabled] = useState(false);
  const [scrollMode, setScrollMode] = useState("camera"); // "camera" or "object"
  const sphereRef = useRef();
  // Leva controls
  const {
    Rotate_X,
    Rotate_Y,
    Object_Color,
    Text_Color,
    Heading_Color,
    Button_Color,
    Scroll_Enabled,
    Scroll_Mode,
    Environment_Preset,
    Zoom_Lock,
    Show_Environment,
    Limited_Zoom,
    Show_Model, // New toggle control for model
    Join_Model,
    // Text_Input, // Added control for text input
  } = useControls({
    Rotate_X: {
      value: 0,
      min: -360,
      max: 360,
      step: 1,
      onChange: (value) => setRotateX(degToRad(value)),
    },
    Rotate_Y: {
      value: 0,
      min: -360,
      max: 360,
      step: 1,
      onChange: (value) => setRotateY(degToRad(value)),
    },
    Text_Color: { value: "#000000" },
    Heading_Color: { value: "#000000" },
    Button_Color: { value: "#ff0000" },
    Object_Color: { value: "#754280" },
    Environment_Preset: {
      value: "lobby",
      options: [
        "apartment",
        "city",
        "dawn",
        "forest",
        "lobby",
        "night",
        "park",
        "studio",
        "sunset",
        "warehouse",
      ],
    },
    Zoom_Lock: {
      value: false,
      onChange: (value) => setZoomLocked(value),
    },
    Show_Environment: {
      value: true,
      label: "Show Environment",
    },
    Limited_Zoom: {
      value: false,
      label: "Limited Zoom",
      onChange: (value) => setIsLimitedZoom(value),
    },
    Text_Input: {
      value: text,
      label: "Edit Text",
      onChange: (value) => setText(value),
    },
    Show_Model: {
      // Add model control
      value: true,
      label: "Show Model",
      onChange: (value) => setModel(value),
    },
    Join_Model: {
      // Add model control
      value: false,
      label: "Join Model",
      onChange: (value) => setJoin(value),
    },Scroll_Enabled: {
      value: false,
      label: "Enable Scroll",
    },
    Scroll_Mode: {
      value: "camera",
      options: ["camera", "object"],
      label: "Scroll Mode",
    },
  });

  useEffect(() => {
    const mediaQuery = window.matchMedia("(max-width:500px)");
    setMobile(mediaQuery.matches);

    const handleMediaQueryChange = (event) => {
      setMobile(event.matches);
    };
    mediaQuery.addEventListener("change", handleMediaQueryChange);

    return () => {
      mediaQuery.removeEventListener("change", handleMediaQueryChange);
    };
  }, []);

  return (
    <div className="h-screen w-screen relative">
      <Leva />
      <Suspense fallback={<Loader />}>
        <Canvas
          gl={{ antialias: true }}
          camera={{ position: [0, 0, 10], fov: 40, near: 0.1, far: 1000 }}
        >
          <ambientLight intensity={1.5} />
          <CameraController cameraPosition={cameraPosition} />
          {Show_Environment && Environment_Preset !== "none" && (
            <Environment preset={Environment_Preset} background={false} />
          )}
          <color attach="background" args={["#64748b"]} />
           <Controls
            isLimitedZoom={isLimitedZoom}
            currentDistanceRef={currentDistanceRef}
            initialDistance={initialDistance}
            zoomLocked={zoomLocked}
          /> 
 {Scroll_Enabled && <CombinedController mode={Scroll_Mode} />}


          {join ? (
            <>
              <BoxGeometry
                text={text}
                ref={sphereRef}
                heading={heading}
                buttonText={buttonText}
                headingColor={Heading_Color}
                buttonColor={Button_Color}
                textColor={Text_Color}
                color={Object_Color}
                position={[0, 0, 0]}
                rotateX={rotateX}
                rotateY={rotateY}
                mobile={mobile}
              />
              <Sphere
                text={text}
                ref={sphereRef}
                headingColor={Heading_Color}
                buttonColor={Button_Color}
                createTextTexture={createTextTexture}
                heading={heading}
                textColor={Text_Color}
                position={[0, 0.1, 0]}
                rotateX={rotateX}
                rotateY={rotateY}
                mobile={mobile}
              />
            </>
          ) : model ? (
            <BoxGeometry
              text={text}
              ref={sphereRef}
              heading={heading}
              buttonText={buttonText}
              headingColor={Heading_Color}
              buttonColor={Button_Color}
              textColor={Text_Color}
              color={Object_Color}
              position={[0, 0, 0]}
              rotateX={rotateX}
              rotateY={rotateY}
              mobile={mobile}
            />
          ) : (
            <Sphere
              text={text}
              ref={sphereRef}
              headingColor={Heading_Color}
              buttonColor={Button_Color}
              createTextTexture={createTextTexture}
              heading={heading}
              textColor={Text_Color}
              position={[0, 0.1, 0]}
              rotateX={rotateX}
              rotateY={rotateY}
              mobile={mobile}
            />
          )}
        </Canvas>
      </Suspense>
    </div>
  );
};

export default GGG;







--------------------------------TaskOne-----------------------------------------------------
import { Decal, Environment, Html, OrbitControls, Plane, Text } from '@react-three/drei';
import { Canvas, useFrame, useLoader, useThree } from '@react-three/fiber';
import React, { useState, useEffect, useRef } from 'react';
import { useSpring } from '@react-spring/three';
import { SketchPicker } from 'react-color';
import { Icon } from '@iconify/react/dist/iconify.js';
import { TextureLoader } from 'three/src/loaders/TextureLoader';
import reactLogo from '/images/images.png';


const degToRad = (degrees) => degrees * (Math.PI / 180);

const curvedText = (text, radius, angle) => {
  const letters = text.split('');
  const segmentAngle = angle / (letters.length - 1);
  return letters.map((letter, i) => {
    const theta = degToRad(-angle / 2 + segmentAngle * i);
    const x = radius * Math.sin(theta);
    const z = radius * Math.cos(theta);
    const rotationY = theta;
    return { letter, position: [x, 0, z], rotation: [0, rotationY, 0] };
  });
};

const BoxGeometry = ({ selectedText, fontSize,planeText, planeHight, textColor = 'black', color = 'orange', position, rotateX, rotateY }) => {
  const radius = 1;
  const angle = 150;
  const letters = curvedText(selectedText, radius, angle);
  const decalTexture = useLoader(TextureLoader, reactLogo);

   // Calculate plane position and rotation
   const planeRadius = radius; // on the sphere surface
   const planeAngle = degToRad(11); // angle on the sphere surface
   const planeX = planeRadius * Math.sin(planeAngle);
   const planeZ = planeRadius * Math.cos(planeAngle);
   const planeRotationX = degToRad(360); // rotate plane to be perpendicular to the sphere surface
   const planeRotationY = planeAngle;
 
  return (
    <mesh position={position} rotation={[rotateX, rotateY, 0]}>
      <sphereGeometry args={[1, 63, 63]} />
      <meshStandardMaterial emissive={color} emissiveIntensity={1} metalness={1} roughness={0} color={color} />
      {letters.map(({ letter, position, rotation }, index) => (
        <Text
          key={index}
          position={position}
          rotation={rotation}
          fontSize={0.1}
          color={textColor}
          anchorX="center"
          anchorY="middle"
        >
          {letter}
        </Text>
      ))}
      <Decal position={[0, 0.5, 0.8]} rotation={[0, 0, 0]} scale={0.5} map={decalTexture} />
        {/* Add a plane with text on it */}
        <Plane position={[planeX, -0.3, planeZ]} rotation={[planeRotationX, planeRotationY, 0]} scale={0.5} args={[1.44, planeHight]}>
        <meshStandardMaterial 
        emissive={color}
         emissiveIntensity={1} 
         metalness={1} roughness={0} color={color} />
        <Text
          fontSize={fontSize}
          color={textColor}
          anchorX="center"      // Align text to the right
          anchorY="middle"        // Align text to the top
          // textAlign="center"    // Align text content to the right within the box
          maxWidth={0.9}      // Ensure text wraps within this width
          lineHeight={1.2}     // Adjust line height if needed
        >
          {planeText}
        </Text>
      </Plane>
    </mesh>
  );
};

const CameraController = ({ cameraPosition }) => {
  const { camera } = useThree();
  const { position } = useSpring({ position: cameraPosition });

  useEffect(() => {
    camera.position.set(...position.get());
    camera.updateProjectionMatrix();
  }, [position, camera]);

  return null;
};

const Controls = ({ isLimitedZoom, currentDistanceRef, initialDistance, zoomLocked }) => {
  const controlsRef = useRef();
  const { camera } = useThree();
  const [initialPositionSet, setInitialPositionSet] = useState(false);
  const zoomLimitsSetRef = useRef(false);

  useEffect(() => {
    if (!initialPositionSet) {
      camera.position.set(0, 0, initialDistance);
      setInitialPositionSet(true);
    }
  }, [camera, initialDistance, initialPositionSet]);

  useEffect(() => {
    if (controlsRef.current) {
      controlsRef.current.enabled = !zoomLocked;
      controlsRef.current.update();
    }
  }, [zoomLocked]);

  useEffect(() => {
    if (controlsRef.current) {
      const currentDistance = currentDistanceRef.current;

      if (isLimitedZoom && !zoomLimitsSetRef.current) {
        if (currentDistance <= 5) {
          controlsRef.current.minDistance = currentDistance - 1;
          controlsRef.current.maxDistance = currentDistance + 1.99;
        } else {
          controlsRef.current.minDistance = currentDistance - 5;
          controlsRef.current.maxDistance = currentDistance + 5;
        }
        zoomLimitsSetRef.current = true;
        console.log(`Min Distance: ${controlsRef.current.minDistance}, Max Distance: ${controlsRef.current.maxDistance}`);
      } else if (!isLimitedZoom) {
        controlsRef.current.minDistance = 2;
        controlsRef.current.maxDistance = 45;
        zoomLimitsSetRef.current = false;
        console.log(`Zoom limits reset: Min Distance: ${controlsRef.current.minDistance}, Max Distance: ${controlsRef.current.maxDistance}`);
      } 

      controlsRef.current.update();
    }
  }, [isLimitedZoom]);

  useFrame(() => {
    if (controlsRef.current) {
      const currentDistance = controlsRef.current.object.position.distanceTo(controlsRef.current.target);
      currentDistanceRef.current = currentDistance;
    }
  });

  return <OrbitControls ref={controlsRef} enableZoom />;
};

const TaskOne = () => {
  const [cameraPosition, setCameraPosition] = useState([0, 0, 3]);
  const [selectedText, setSelectedText] = useState('The world is round and you can meet any one any time');
  const [fontSize, setFontSize] = useState(0.1);
  const [planeHight, setplaneHight] = useState(0.99);
  const [planeText, setPlaneText] = useState('This is for Plane Text');
  const [color, setColor] = useState('#390A63');
  const [textColor, setTextColor] = useState('#FFFFFF');
  const [rotateX, setRotateX] = useState(0);
  const [rotateY, setRotateY] = useState(0);
  const [envPreset, setEnvPreset] = useState('dawn');
  const rotateIntervalRef = useRef(null);
  const [zoomLocked, setZoomLocked] = useState(false);
  const [isLimitedZoom, setIsLimitedZoom] = useState(false);
  const currentDistanceRef = useRef(3); // Default initial distance
  const initialDistance = 3; // Dynamic initial distance

  const startRotation = (direction) => {
    if (rotateIntervalRef.current) {
      clearInterval(rotateIntervalRef.current);
    }

    rotateIntervalRef.current = setInterval(() => {
      switch (direction) {
        case 'left':
          setRotateY((prevRotateY) => prevRotateY - degToRad(1));
          break;
        case 'right':
          setRotateY((prevRotateY) => prevRotateY + degToRad(1));
          break;
        case 'up':
          setRotateX((prevRotateX) => prevRotateX - degToRad(1));
          break;
        case 'down':
          setRotateX((prevRotateX) => prevRotateX + degToRad(1));
          break;
        default:
          break;
      }
    }, 40);
  };

  const stopRotation = () => {
    if (rotateIntervalRef.current) {
      clearInterval(rotateIntervalRef.current);
    }
  };

  const handleTextColorChange = (color) => {
    setTextColor(color.hex);
  };

  const handleColorChange = (color) => {
    setColor(color.hex);
  };

  const handleEnvPresetChange = (e) => {
    setEnvPreset(e.target.value);
  };

  const handleFontSizeChange = (e) => {
    const value = e.target.value;
    if (value === "0.1") {
      setFontSize(0.1);
      setplaneHight(0.99);
    } else if (value === "0.2") {
      setFontSize(0.2);
      setplaneHight(2.66);
    } else if (value === "0.3") {
      setFontSize(0.3);
      setplaneHight(5.66);
    }
  };

  const handleTextChange = (e) => {
    setSelectedText(e.target.value);
  };
  const toggleZoomLock = () => {
    setZoomLocked((prev) => !prev);
  };
  const handlePlaneTextChange = (e) => {
    setPlaneText(e.target.value);
  };

  const toggleLimitedZoom = () => {
    setIsLimitedZoom((prev) => !prev);
  };

  return (
    <div className="h-screen w-screen relative">
      <Canvas camera={{ position: [0, 0, 0.1], fov: 10 }}>
      <BoxGeometry
          selectedText={selectedText}
          fontSize={fontSize}
          planeText={planeText}
          planeHight={planeHight}
          textColor={textColor}
          color={color}
          position={[0, 0, 0]}
          rotateX={rotateX}
          rotateY={rotateY}
        />
        <CameraController cameraPosition={cameraPosition} />
        <Environment preset={envPreset} background={false} />
        <color attach="background" args={['#64748b']} />
        <Controls 
          isLimitedZoom={isLimitedZoom}
          currentDistanceRef={currentDistanceRef}
          initialDistance={initialDistance}
          zoomLocked={zoomLocked}
        />
        
        {/* <BoxGeometry text={Text} textColor={textColor} color={color} position={[0, 0.1, 0]} rotateX={rotateX} rotateY={rotateY} /> */}
        <Html>
          <div className='flex space-x-2 absolute bottom-[25rem] left-[550px] transform -translate-x-1/2'>
            
            <div>

              <button
                onMouseDown={() => startRotation('up')}
                onMouseUp={stopRotation}
                onMouseLeave={stopRotation}
                className="relative overflow-hidden rounded-lg h-12 group hover:shadow-lg hover:scale-105 transition duration-500 before:absolute before:inset-0 before:rounded-lg before:bg-gradient-to-br before:from-pink-400 before:via-purple-400 before:to-indigo-400"
              >
                <span className="relative flex items-center text-white font-bold px-4 py-2">Up</span>
              </button>
            </div>
            <button
              onMouseDown={() => startRotation('left')}
              onMouseUp={stopRotation}
              onMouseLeave={stopRotation}
              className="relative overflow-hidden rounded-lg h-12 group hover:shadow-lg hover:scale-105 transition duration-500 before:absolute before:inset-0 before:rounded-lg before:bg-gradient-to-br before:from-pink-400 before:via-purple-400 before:to-indigo-400"
            >
              <span className="relative flex items-center text-white font-bold px-4 py-2">Left</span>
            </button>
            <button
              onMouseDown={() => startRotation('down')}
              onMouseUp={stopRotation}
              onMouseLeave={stopRotation}
              className="relative overflow-hidden rounded-lg h-12 group hover:shadow-lg hover:scale-105 transition duration-500 before:absolute before:inset-0 before:rounded-lg before:bg-gradient-to-br before:from-pink-400 before:via-purple-400 before:to-indigo-400"
            >
              <span className="relative flex items-center text-white font-bold px-4 py-2">Down</span>
            </button>
            <button
              onMouseDown={() => startRotation('right')}
              onMouseUp={stopRotation}
              onMouseLeave={stopRotation}
              className="relative overflow-hidden rounded-lg h-12 group hover:shadow-lg hover:scale-105 transition duration-500 before:absolute before:inset-0 before:rounded-lg before:bg-gradient-to-br before:from-pink-400 before:via-purple-400 before:to-indigo-400"
            >
              <span className="relative flex items-center text-white font-bold px-4 py-2">Right</span>
            </button>
          </div>
          
          <div className='flex items-center right-24 bottom-[25rem] space-x-8 absolute transform -translate-x-1/2 p-4 rounded'>
            <div className="relative group">
              <button className="relative overflow-hidden rounded-lg h-12 group hover:shadow-lg hover:scale-105 transition duration-500 before:absolute before:inset-0 before:rounded-lg before:bg-gradient-to-br before:from-pink-400 before:via-purple-400 before:to-indigo-400">
                <span className="relative flex items-center text-white  font-bold px-4 py-2">Color <Icon className='mx-1' icon="pepicons-print:color-picker" /></span>
              </button>
              <div className="absolute z-10 hidden group-hover:block  p-2 bg-white border border-gray-300 rounded shadow-lg">
                <SketchPicker color={color} onChangeComplete={handleColorChange} />
              </div>
            </div>
            <div className="relative group">
              <button className="relative overflow-hidden rounded-lg h-12 group hover:shadow-lg hover:scale-105 transition duration-500 before:absolute before:inset-0 before:rounded-lg before:bg-gradient-to-br before:from-pink-400 before:via-purple-400 before:to-indigo-400">
                <span className="relative flex items-center text-white font-bold px-4 py-2">Text <Icon className='mx-1' icon="pepicons-print:color-picker" /></span>
              </button>
              <div className="absolute z-10 hidden group-hover:block mt-0 bg-white border border-gray-300 rounded shadow-lg">
                <SketchPicker color={textColor} onChangeComplete={handleTextColorChange} />
              </div>
            </div>
            <select value={envPreset} onChange={handleEnvPresetChange} className="inline-flex mt-2 p-2 border border-slate-300 rounded focus:outline-none focus:ring-1 focus:ring-slate-300">
              <option value="city">City</option>
              <option value="sunset">Sunset</option>
              <option value="dawn">Dawn</option>
              <option value="night">Night</option>
              <option value="forest">Forest</option>
              <option value="apartment">Apartment</option>
              <option value="studio">Studio</option>
              <option value="warehouse">Warehouse</option>
              <option value="park">Park</option>
              <option value="lobby">Lobby</option>
            </select>
            {/* <button
              onClick={toggleZoomLock}
              className="relative overflow-hidden rounded-lg h-12 group hover:shadow-lg hover:scale-105 transition duration-500 before:absolute before:inset-0 before:rounded-lg before:bg-gradient-to-br before:from-pink-400 before:via-purple-400 before:to-indigo-400"
            >
              <span className="relative flex items-center text-white font-bold px-4 py-2">
              {zoomLocked ? <Icon height={"30px"} icon="material-symbols:lock" /> : <Icon height={"30px"} icon="bi:unlock-fill" />}
              </span>
            </button> */}
            <button
              onClick={toggleLimitedZoom}
              className="relative overflow-hidden rounded-lg h-12 group hover:shadow-lg hover:scale-105 transition duration-500 before:absolute before:inset-0 before:rounded-lg before:bg-gradient-to-br before:from-pink-400 before:via-purple-400 before:to-indigo-400"
            >
              <span className="relative flex items-center text-white font-bold w-16  justify-center ">
              {isLimitedZoom ? <Icon height={"30px"} icon="material-symbols:lock" /> : <Icon height={"30px"} icon="bi:unlock-fill" />}
              </span>
            </button>
         

            
          </div>
          <div className='relative right-[45.5rem] bottom-[10rem]'>
               <label className='text-white'>
          Select font size:
          <select
            className="border p-1 rounded w-full mb-10 text-black"
            value={fontSize}
            onChange={handleFontSizeChange}
          >
            <option value="0.1">Small</option>
            <option value="0.2">Medium</option>
            <option value="0.3">Large</option>
          </select>
        </label>
            
              
        <div className=" top-4 w-48 left-4 bg-white bg-opacity-75 p-4 rounded shadow-md">
        <label>
          Enter text:
          <textarea
            className="border p-1 rounded w-full"
            value={planeText} onChange={handlePlaneTextChange}
            rows={3}
          />
        </label>
            </div>
        </div>
        </Html>
      </Canvas>
    </div>
  );
};

export default TaskOne;


-----------------------------Task 2 -----------------------------------------------------

import { Decal, Environment, Html, OrbitControls, Text} from '@react-three/drei';
import { Canvas, useFrame, useLoader, useThree } from '@react-three/fiber';
import React, { useState, useEffect, useRef } from 'react';
import { useSpring } from '@react-spring/three';
import { TextureLoader, CanvasTexture, LinearFilter } from 'three';
import { BlockPicker} from 'react-color';
import { Icon } from '@iconify/react/dist/iconify.js';
// import { TextureLoader } from 'three/src/loaders/TextureLoader';
// import reactLogo from '/images.png';
// import { texture } from 'three/examples/jsm/nodes/Nodes.js';



const degToRad = (degrees) => degrees * (Math.PI / 180);

const createTextTexture = (text, heading, buttonText, headingColor, textColor, buttonColor) => {
  const canvas = document.createElement('canvas');
  canvas.width = 4300; // Adjust this to control the resolution
  canvas.height = 2080; // Adjust this to control the resolution
  const context = canvas.getContext('2d');

  // Background
  context.fillStyle = 'white';
  context.fillRect(0, 0, canvas.width, canvas.height);

  // Heading
  context.font = 'bold 150px Arial';
  context.fillStyle = headingColor;
  context.textAlign = 'center';
  context.textBaseline = 'middle';
  context.lineJoin = 'round';
  context.miterLimit = 2;
  context.fillText(heading, canvas.width / 2, 200);

  // Button
  const buttonWidth = 800; // Adjusted width
  const buttonHeight = 200; // Adjusted height
  const buttonX = (canvas.width / 2) - (buttonWidth / 2);
  const buttonY = 400; // Adjusted y-position

  context.fillStyle = buttonColor;
  context.fillRect(buttonX, buttonY, buttonWidth, buttonHeight);
  context.font = 'bold 80px Arial'; // Larger font size
  context.fillStyle = textColor;
  context.fillText(buttonText, canvas.width / 2, buttonY + (buttonHeight / 2));

  // Paragraph
  context.font = '50px Arial'; // Larger font size
  context.fillStyle = buttonColor;
  context.textAlign = 'center';

  const words = text.split(' ');
  let line = '';
  let y = buttonY + buttonHeight + 100; // Adjusted y-position
  const lineHeight = 100; // Increased line height

  words.forEach((word) => {
    const testLine = `${line}${word} `;
    const metrics = context.measureText(testLine);
    const testWidth = metrics.width;
    if (testWidth > canvas.width - 40 && line !== '') {
      context.fillText(line, canvas.width / 2, y);
      line = `${word} `;
      y += lineHeight;
    } else {
      line = testLine;
    }
  });
  context.fillText(line, canvas.width / 2, y);

  const texture = new CanvasTexture(canvas);
  texture.anisotropy = 16; // Increase anisotropy for better quality at an angle
  texture.minFilter = LinearFilter; // Use linear filter for smoother appearance
  texture.magFilter = LinearFilter; // Use linear filter for smoother appearance
  texture.generateMipmaps = false; // Disable mipmaps if text appears blurry

  return texture;
};


const BoxGeometry = ({ text,mobile, heading, buttonText, headingColor, buttonColor, textColor = 'black', color = 'orange', position, rotateX, rotateY }) => {
 
//   const decalTexture = useLoader(TextureLoader, reactLogo);
const texture = createTextTexture(text, heading, buttonText, headingColor,textColor, buttonColor);

  return (
    <mesh position={position}
     rotation={[rotateX, rotateY, 0]} scale={mobile ? 0.70 : 1}
     >

      <sphereGeometry args={[1, 63, 63]} />
      <meshStandardMaterial
      //  emissive={color}
      //  emissiveIntensity={1}
        metalness={0} roughness={0} opacity={1} color={color} map={texture} />
      {/* {letters.map(({ letter, position, rotation }, index) => (
        <Text
          key={index}
          position={position}
          rotation={rotation}
          fontSize={0.1}
          color={textColor}
          anchorX="center"
          anchorY="middle"
        >
          {letter}
        </Text>
      ))}
      <Decal position={[0, 0.5, 0.8]} rotation={[0, 0, 0]} scale={0.5} map={decalTexture} /> */}
    </mesh>
  );
};

const CameraController = ({ cameraPosition }) => {
  const { camera } = useThree();
  const { position } = useSpring({ position: cameraPosition });

  useEffect(() => {
    camera.position.set(...position.get());
    camera.updateProjectionMatrix();
  }, [position, camera]);

  return null;
};

const Controls = ({ isLimitedZoom, currentDistanceRef, initialDistance, zoomLocked }) => {
  const controlsRef = useRef();
  const { camera } = useThree();
  const [initialPositionSet, setInitialPositionSet] = useState(false);
  const zoomLimitsSetRef = useRef(false);

  useEffect(() => {
    if (!initialPositionSet) {
      camera.position.set(0, 0, initialDistance);
      setInitialPositionSet(true);
    }
  }, [camera, initialDistance, initialPositionSet]);

  useEffect(() => {
    if (controlsRef.current) {
      controlsRef.current.enabled = !zoomLocked;
      controlsRef.current.update();
    }
  }, [zoomLocked]);

  useEffect(() => {
    if (controlsRef.current) {
      const currentDistance = currentDistanceRef.current;

      if (isLimitedZoom && !zoomLimitsSetRef.current) {
        if (currentDistance <= 5) {
          controlsRef.current.minDistance = currentDistance - 1;
          controlsRef.current.maxDistance = currentDistance + 1.10;
        } else {
          controlsRef.current.minDistance = currentDistance - 5;
          controlsRef.current.maxDistance = currentDistance + 5;
        }
        zoomLimitsSetRef.current = true;
        console.log(`Min Distance: ${controlsRef.current.minDistance}, Max Distance: ${controlsRef.current.maxDistance}`);
      } else if (!isLimitedZoom) {
        controlsRef.current.minDistance = 2;
        controlsRef.current.maxDistance = 45;
        zoomLimitsSetRef.current = false;
        console.log(`Zoom limits reset: Min Distance: ${controlsRef.current.minDistance}, Max Distance: ${controlsRef.current.maxDistance}`);
      } 

      controlsRef.current.update();
    }
  }, [isLimitedZoom]);
  useFrame(() => {
    if (controlsRef.current) {
      const currentDistance = controlsRef.current.object.position.distanceTo(controlsRef.current.target);
      currentDistanceRef.current = currentDistance;
    }
  });

  return <OrbitControls ref={controlsRef} enableZoom />;
};

const GGG= () => {
  const [cameraPosition, setCameraPosition] = useState([0, 0, 3]);
  const [buttonText, setButtonText] = useState('Click Me');
  const [heading, setHeading] = useState('Global Text');
  const [text, setText] = useState('TLorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.  Lorem ipsum dolor sit amet consectetur adipisicing elit. Possimus aperiam hic sapiente, quam doloribus eos assumenda soluta iusto fugit perspiciatis quo, vitae vel sed. Harum eveniet sequi ut laudantium iure. Lorem ipsum dolor sit amet consectetur adipisicing elit. Possimus aperiam hic sapiente, quam doloribus eos assumenda soluta iusto fugit perspiciatis quo, vitae vel sed. Harum eveniet sequi ut laudantium iure. Lorem ipsum dolor sit amet consectetur adipisicing elit. Possimus aperiam hic sapiente, quam doloribus eos assumenda soluta iusto fugit perspiciatis quo, vitae vel sed. Harum eveniet sequi ut laudantium iure. Lorem ipsum dolor sit amet consectetur adipisicing elit. Possimus aperiam hic sapiente, quam doloribus eos assumenda soluta iusto fugit perspiciatis quo, vitae vel sed. Harum eveniet sequi ut laudantium iure. Lorem ipsum  Lorem ipsum dolor sit  perspiciatis quo, vitae vel sed. Harum eveniet sequi ut laudantium iure. Lorem ipsum dolor sit amet consectetur adipisicing elit. Possimus aperiam hic sapiente, quam doloribus eos assumenda soluta iusto fugit perspiciatis quo, vitae vel sed. Harum eveniet sequi ut laudantium iure. Lorem ipsum  Lorem ipsum dolor sit  perspiciatis quo, vitae vel sed. Harum eveniet sequi ut laudantium iure. Lorem ipsum dolor sit amet consectetur adipisicing elit. Possimus aperiam hic sapiente, quam doloribus eos assumenda soluta iusto fugit perspiciatis quo, vitae vel sed. Harum eveniet sequi ut laudantium iure. Lorem ipsum  Lorem ipsum dolor sit  perspiciatis quo, vitae vel sed. Harum eveniet sequi ut laudantium iure. Lorem ipsum dolor sit amet consectetur adipisicing elit. Possimus aperiam hic sapiente, quam doloribus eos assumenda soluta iusto fugit perspiciatis quo, vitae vel sed. Harum eveniet sequi ut laudantium iure. Lorem ipsum  Lorem ipsum dolor sit  perspiciatis quo, vitae vel sed. Harum eveniet sequi ut laudantium iure. Lorem ipsum dolor sit amet consectetur adipisicing elit. Possimus aperiam hic sapiente, quam doloribus eos assumenda soluta iusto fugit perspiciatis quo, vitae vel sed. Harum eveniet sequi ut laudantium iure. Lorem ipsum  Lorem ipsum dolor sit amet consectetur adipisicing elit. Possimus aperiam hic sapiente, quam doloribus eos assumenda soluta iusto fugit perspicia Lorem ipsum dolor sit amet consectetur adipisicing elit. Possimus aperiam hic sapiente, quam doloribus eos assumenda soluta iusto fugit perspiciatis quo, vitae vel sed. Harum eveniet sequi ut laudantium iure. Lorem ipsum dolor sit amet consectetur adipisicing elit. Possimus aperiam hic sapiente, quam doloribus eos assumenda soluta iusto fugit perspiciatis quo, vitae vel sed. Harum eveniet sequi ut laudantium iure. Lorem ipsum dolor sit amet consectetur adipisicing elit. Possimus aperiam hic sapiente, quam doloribus eos assumenda soluta iusto fugit perspiciatis quo, vitae vel sed. Harum eveniet sequi ut laudantium iure. Lorem ipsum dolor sit amet consectetur adipisicing elit. Possimus aperiam hic sapiente, quam doloribus eos assumenda soluta iusto fugit perspiciatis quo, vitae vel sed. Harum eveniet sequi ut laudantium iure.a soluta iusto fugit perspiciatis quo, vitae vel sed. Harum eveniet sequi ut laudantium iure. dolor sit amet consectetur adipisicing elit. Possimus aperiam hic sapiente, quam doloribus eos assumenda soluta iusto fugit perspiciatis quo, vitae vel sed. Harum eveniet sequi ut laudantium iure');
  const [color, setColor] = useState('#754280');
  const [textColor, setTextColor] = useState('#000000');
  const [headingColor, setHeadingColor] = useState('#000000'); // Initial color for heading
const [buttonColor, setButtonColor] = useState('#ff0000'); // Initial color for button

  const [rotateX, setRotateX] = useState(0);
  const [rotateY, setRotateY] = useState(0);
  const [envPreset, setEnvPreset] = useState('dawn');
  const rotateIntervalRef = useRef(null);
  const [zoomLocked, setZoomLocked] = useState(false);
  const [isLimitedZoom, setIsLimitedZoom] = useState(false);
  const currentDistanceRef = useRef(3); // Default initial distance
  const initialDistance = 3; // Dynamic initial distance
  const [environmentActive, setEnvironmentActive] = useState(true);
  const [mobile, setmobile] = useState(false);
  useEffect(() => {
    const mediaQuery = window.matchMedia("(max-width:500px)");
    setmobile(mediaQuery.matches);

    const handleMediaQuaryChange = (event) => {
      setmobile(event.matches);
      console.log('Media query matched:', event.matches); // Debug log
      console.log('Current mobile state:', mobile);  
      
      
    };
    mediaQuery.addEventListener("change", handleMediaQuaryChange);

    return () => {
      mediaQuery.removeEventListener("change", handleMediaQuaryChange);
    };
  }, []);

  useEffect(() => {
    console.log('Updated mobile state:', mobile);
  }, [mobile]);
  
  const startRotation = (direction) => {
    if (rotateIntervalRef.current) {
      clearInterval(rotateIntervalRef.current);
    }

    rotateIntervalRef.current = setInterval(() => {
      switch (direction) {
        case 'left':
          setRotateY((prevRotateY) => prevRotateY - degToRad(1));
          break;
        case 'right':
          setRotateY((prevRotateY) => prevRotateY + degToRad(1));
          break;
        case 'up':
          setRotateX((prevRotateX) => prevRotateX - degToRad(1));
          break;
        case 'down':
          setRotateX((prevRotateX) => prevRotateX + degToRad(1));
          break;
        default:
          break;
      }
    }, 40);
  };
  const handleHeadingColorChange = (color) => {
    setHeadingColor(color.hex);
};

const handleButtonColorChange = (color) => {
    setButtonColor(color.hex);
};

  const stopRotation = () => {
    if (rotateIntervalRef.current) {
      clearInterval(rotateIntervalRef.current);
    }
  };

  const handleTextColorChange = (color) => {
    setTextColor(color.hex);
  };

  const handleColorChange = (color) => {
    setColor(color.hex);
  };

  const handleEnvPresetChange = (e) => {
    if (e.target.value === 'default') {
      setEnvironmentActive(!environmentActive);
    } else {
      setEnvPreset(e.target.value);
    }
  };

  const toggleZoomLock = () => {
    setZoomLocked((prev) => !prev);
  };

  const toggleLimitedZoom = () => {
    setIsLimitedZoom((prev) => !prev);
  };

  return (
    <div className="h-screen w-screen relative">
      <Canvas gl={{antialias:true}} camera={{ position: [0, 0, 0.1], fov: 10, near: 0.1, far: 1000}}>
      <ambientLight intensity={1.5} />
      {/* <directionalLight position={[5, 5, 5]} intensity={1} /> */}
        <CameraController cameraPosition={cameraPosition} />
        {environmentActive && <Environment preset={envPreset} background={false} />}
        <color attach="background" args={['#64748b']} />
        <Controls 
          isLimitedZoom={isLimitedZoom}
          currentDistanceRef={currentDistanceRef}
          initialDistance={initialDistance}
          zoomLocked={zoomLocked}
        />
        <BoxGeometry text={text} headingColor={headingColor}
  buttonColor={buttonColor} buttonText={buttonText} mobile={mobile} heading={heading}  textColor={textColor} color={color} position={[0, 0.1, 0]} rotateX={rotateX} rotateY={rotateY} />
  {/* console.log("is mobile":mobile) */}
 
        <Html>
          <div className='flex max-sm:left-0 max-sm:-top-[135px] max-sm:gap-0 max-sm: space-x-1 absolute bottom-48 left-[550px] transform -translate-x-1/2'>
            <div>
              <button
                onMouseDown={() => startRotation('up')}
                onMouseUp={stopRotation}
                onMouseLeave={stopRotation}
                className="relative overflow-hidden rounded-lgmax-sm:rounded-none max-sm:hidden h-12 max-sm:h-5 group hover:shadow-lg hover:scale-105 transition duration-500 before:absolute  before:inset-0 before:rounded-lg before:bg-gradient-to-br before:from-pink-400 before:via-purple-400 before:to-indigo-400"
              >
                <span className="relative  flex items-center text-white font-bold
     max-sm:text-sm px-4 max-sm:px-1 py-2 max-sm:py-0">Up</span>
              </button>
            </div>
            <button
              onMouseDown={() => startRotation('left')}
              onMouseUp={stopRotation}
              onMouseLeave={stopRotation}
              className="relative overflow-hidden rounded-lgmax-sm:rounded-none max-sm:hidden  h-12 max-sm:h-5 group hover:shadow-lg hover:scale-105 transition duration-500 before:absolute  before:inset-0 before:rounded-lg before:bg-gradient-to-br before:from-pink-400 before:via-purple-400 before:to-indigo-400"
            >
              <span className="relative flex items-center text-white font-bold
     max-sm:text-sm px-4 max-sm:px-1 py-2 max-sm:py-0">Left</span>
            </button>
            <button
              onMouseDown={() => startRotation('down')}
              onMouseUp={stopRotation}
              onMouseLeave={stopRotation}
              className="relative overflow-hidden rounded-lgmax-sm:rounded-none max-sm:hidden  h-12 max-sm:h-5 group hover:shadow-lg hover:scale-105 transition duration-500 before:absolute  before:inset-0 before:rounded-lg before:bg-gradient-to-br before:from-pink-400 before:via-purple-400 before:to-indigo-400"
            >
              <span className="relative flex items-center text-white font-bold
     max-sm:text-sm px-4 max-sm:px-1 py-2 max-sm:py-0">Down</span>
            </button>
            <button
              onMouseDown={() => startRotation('right')}
              onMouseUp={stopRotation}
              onMouseLeave={stopRotation}
              className="relative overflow-hidden rounded-lgmax-sm:rounded-none max-sm:hidden  h-12 max-sm:h-5 group hover:shadow-lg hover:scale-105 transition duration-500 before:absolute  before:inset-0 before:rounded-lg before:bg-gradient-to-br before:from-pink-400 before:via-purple-400 before:to-indigo-400"
            >
              <span className="relative flex items-center text-white font-bold
     max-sm:text-sm px-4 max-sm:px-1 py-2 max-sm:py-0">Right</span>
            </button>
          </div>
          <div className='flex max-sm:flex-col max-sm:justify-center max-sm:-right-[135px] max-sm:gap-2 max-sm:-bottom-20 items-center bottom-48 -right-[429px] space-x-8 absolute transform -translate-x-1/2 p-4 rounded'>
            <div className="relative group">
              <button className="relative overflow-hidden rounded-lgmax-sm:rounded-none max-sm:hidden  h-12 max-sm:h-5 group hover:shadow-lg hover:scale-105 transition duration-500 before:absolute  before:inset-0 before:rounded-lg before:bg-gradient-to-br before:from-pink-400 before:via-purple-400 before:to-indigo-400">
                <span className="relative flex items-center text-white font-bold
     max-sm:text-sm px-4 max-sm:px-1 py-2 max-sm:py-0">Color <Icon className='mx-1' icon="pepicons-print:color-picker" /></span>
              </button>
              <div className="absolute z-10 hidden group-hover:block  p-2 bg-white border border-gray-300 rounded shadow-lg">
                <BlockPicker  className="custom-sketch-picker" 
        //         styles={{
        //   default: {
        //     picker: {
        //       width: '100px', 
        //       height: '300px', 
        //     },
        //   },
        // }} 
        color={color} onChangeComplete={handleColorChange} />
              </div>
            </div>
            <div className="relative group">
  <button className="relative overflow-hidden rounded-lgmax-sm:rounded-none max-sm:hidden  h-12 max-sm:h-5 group hover:shadow-lg hover:scale-105 transition duration-500 before:absolute  before:inset-0 before:rounded-lg before:bg-gradient-to-br before:from-pink-400 before:via-purple-400 before:to-indigo-400">
    <span className="relative flex items-center text-white font-bold
     max-sm:text-sm px-4 max-sm:px-1 py-2 max-sm:py-0">
      Text <Icon className='mx-1' icon="pepicons-print:color-picker" />
    </span>
  </button>
  <div className="absolute z-10 hidden group-hover:block  p-2 bg-white border border-gray-300 rounded shadow-lg">
    <BlockPicker className="custom-sketch-picker" color={headingColor} onChangeComplete={handleHeadingColorChange} />
  </div>
</div>
{/* <label className="relative inline-flex items-center cursor-pointer">
          <input
            type="checkbox"
            checked={environmentActive}
            onChange={() => setEnvironmentActive(!environmentActive)}
            className="sr-only peer"
          />
          <div className="w-11 h-6 bg-gray-200 rounded-full  peer-checked:bg-indigo-600 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all dark:border-gray-600"></div>
          
        </label>  */}
<div className="relative group">
  <button className="relative overflow-hidden rounded-lgmax-sm:rounded-none max-sm:hidden  h-12 max-sm:h-5 group hover:shadow-lg hover:scale-105 transition duration-500 before:absolute  before:inset-0 before:rounded-lg before:bg-gradient-to-br before:from-pink-400 before:via-purple-400 before:to-indigo-400">
    <span className="relative flex items-center text-white font-bold
     max-sm:text-sm px-4 max-sm:px-1 py-2 max-sm:py-0">
      Button <Icon className='mx-1' icon="pepicons-print:color-picker" />
    </span>
  </button>
  <div className="absolute z-10 hidden group-hover:block  p-2 max-sm:p-0 bg-white border border-gray-300 rounded shadow-lg">
    <BlockPicker className="custom-sketch-picker" color={buttonColor} onChangeComplete={handleButtonColorChange} />
  </div>
</div>


            {/* <div className="relative group">
              <button className="relative overflow-hidden rounded-lg h-12 group hover:shadow-lg hover:scale-105 transition duration-500 before:absolute before:inset-0 before:rounded-lg before:bg-gradient-to-br before:from-pink-400 before:via-purple-400 before:to-indigo-400">
                <span className="relative flex items-center text-white font-bold px-4 py-2">Text <Icon className='mx-1' icon="pepicons-print:color-picker" /></span>
              </button>
              <div className="absolute z-10 hidden group-hover:block mt-0 bg-white border border-gray-300 rounded shadow-lg">
                <BlockPicker color={textColor} onChangeComplete={handleTextColorChange} />
              </div>
            </div> */}
            <select value={envPreset} onChange={handleEnvPresetChange} className="inline-flex mt-2 p-2 w-28 max-sm:hidden border border-slate-300 rounded focus:outline-none focus:ring-1 focus:ring-slate-300">
              <option value="default">Default</option>
              <option value="city">City</option>
              <option value="sunset">Sunset</option>
              <option value="dawn">Dawn</option>
              <option value="night">Night</option>
              <option value="forest">Forest</option>
              <option value="apartment">Apartment</option>
              <option value="studio">Studio</option>
              <option value="warehouse">Warehouse</option>
              <option value="park">Park</option>
              <option value="lobby">Lobby</option>
            </select>
                 {/* <button
              onClick={toggleZoomLock}
              className="relative overflow-hidden rounded-lg h-12 group hover:shadow-lg hover:scale-105 transition duration-500 before:absolute before:inset-0 before:rounded-lg before:bg-gradient-to-br before:from-pink-400 before:via-purple-400 before:to-indigo-400"
            >
              <span className="relative flex items-center text-white font-bold px-4 py-2">
              {zoomLocked ? <Icon height={"30px"} icon="material-symbols:lock" /> : <Icon height={"30px"} icon="bi:unlock-fill" />}
              </span>
            </button> */}
            <button
              onClick={toggleLimitedZoom}
              className="relative overflow-hidden rounded-lgmax-sm:rounded-none max-sm:hidden  h-12 max-sm:h-5 group hover:shadow-lg hover:scale-105 transition duration-500 before:absolute  before:inset-0 before:rounded-lg before:bg-gradient-to-br before:from-pink-400 before:via-purple-400 before:to-indigo-400"
            >
              <span className="relative flex items-center text-white font-bold
     max-sm:font-light max-sm:text-sm px-4 max-sm:px-1 py-2 max-sm:py-0">
              {isLimitedZoom ? <Icon className='h-[30px] max-sm:h-[10px]'  icon="material-symbols:lock" /> : <Icon className='h-[30px] max-sm:h-[10px]' icon="bi:unlock-fill" />}
              </span>
            </button>
          </div>
        </Html>
      </Canvas>
    </div>
  );
};

export default GGG;
