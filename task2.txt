-----------------------------Task Six---------------------------------------------
BSphere:
import React, { useRef, useState, useMemo, useEffect } from "react";
import { Canvas, useFrame, useLoader } from "@react-three/fiber";
import { OrbitControls, Decal, Sphere, Environment } from "@react-three/drei";
import * as THREE from "three";
import bg from "/images/back.jpeg";
import Loader from "./Loader";
import { CanvasTexture,LinearFilter } from "three";

const DecalOnSphere = () => {
  const sphereRef = useRef();
  const [MailPosition] = useState(new THREE.Vector3(0, 0.09, 2)); // Position of decal
  const [MailScale] = useState(new THREE.Vector3(0.09, 0.10, 0.1)); // Increase scale of decal
  const [InstaScale] = useState(new THREE.Vector3(0.09, 0.10, 0.1)); // Increase scale of decal
  const [SafariScale] = useState(new THREE.Vector3(0.09, 0.10, 0.1)); // Increase scale of decal
  const [PhotoScale] = useState(new THREE.Vector3(0.09, 0.10, 0.1)); // Increase scale of decal
  const MailRotation = new THREE.Euler(0, 0, 0); // Decal rotation
  const Mailtexture = useLoader(THREE.TextureLoader, "/images/Untitled.png");
  const Instatexture = useLoader(THREE.TextureLoader, "/images/instagram copy.png");
  const Phototexture = useLoader(THREE.TextureLoader, "/images/Photo.png");
  const Safaritexture = useLoader(THREE.TextureLoader, "/images/safari copy.png");
  const bgtexture = useLoader(THREE.TextureLoader, bg);
  // Create a canvas texture with the paragraph text
  const createTextTexture = () => {
    const canvas = document.createElement("canvas");
    const context = canvas.getContext("2d");
    canvas.width = 6200;
    canvas.height = 6200;

    // Make the background transparent by not filling it
    context.clearRect(0, 0, canvas.width, canvas.height);
    context.textRendering = "optimizeLegibility";

    // Text settings
    context.fillStyle = "white"; // Text color to contrast with the green sphere
    context.font = "100 150px CustomFont";
    context.textAlign = "center";
    context.textBaseline = "middle";

    // Add your paragraph text
    const paragraphText = `
    The quick brown fox jumps over the lazy dog. The quick brown fox jumps over the lazy dog. The quick brown fox jumps over the lazy dog again and again. The quick brown fox 
    jumps over the lazy dog. The quick brown fox jumps over the lazy dog. The quick brown fox jumps over the lazy dog swiftly and elegantly. The quick brown fox jumps over the
     lazy dog. The quick brown fox jumps over the lazy dog. The quick brown fox jumps over the lazy dog with grace and speed. The quick brown fox jumps over the lazy dog. The
     quick brown fox jumps over the lazy dog. The quick brown fox leaps over with unmatched energy.The agile feline prowls in the night. The agile feline prowls in the night.
     
      The agile feline prowls in the shadows with a graceful leap. The agile feline prowls in the night. The agile feline prowls in the night. The agile feline moves silently,
  always out of sight.The moon glows bright in the sky tonight. The moon glows bright in the sky tonight. The moon lights up the night 
  like a shining beacon. The moon glows bright in the sky tonight. The moon glows bright in the sky tonight.The stars twinkle as they keep their secret glow. 
  The moon glows bright in the sky tonight. The moon glows bright in the sky tonight. The endless expanse continues to stretch beyond sight. The moon glows bright in the sky tonight.
   The moon glows bright in the sky tonight. The moon illuminates the dark as the earth spins slowly.Amidst the silence, whispers of the wind echo
    in every corner, stirring the trees gently and creating a soft lullaby as nature falls into slumber.

    The old zoom tower stands tall in the middle of the town. The old wasd tower stands tall with its hands frozen at midnight.The old alot tower is a relic from another era, watching silently.
     The old work tower stands tall in the middle of the town. The old alpha tower stands tall with its bricks weathered by time. The old beta tower echoes the memories of days long gone. 
     The old loop tower stands tall in the middle of the town. The old gama tower stands tall as the wind howls through its hollow frame, whispering tales from the past. The old zero tower
      stands tall in the middle of the town. The old Not tower stands tall with a lone raven perched on its peak, gazing over the cobblestone streets below.

The streets are empty, deserted under Lorem ipsum dolor sit amet, consectetur adipiscing elit.Lorem , shadows creeping into every corner. The streets are empty, save for the gentle rustling of leaves. 
The streets are empty, deserted under ipsum dolor sit amet, consectetur adipiscing elit.Lorem ipsum , an eerie silence hanging in the air. The streets are empty, echoing the sound of distant footsteps.
 The streets are empty, deserted under The quick brown fox jumps over the lazy dog, but every window holds a story. The streets are empty, yet whispers from the past seem to linger.
  The streets are empty, deserted under  The agile feline prowls in the night. The agile feline prowls, lit by the dim flickering lights. The streets are empty, carrying the scent of the rain that just fell.


A lone figure emerges, cloaked in mystery and shadow. A lone figure emerges with a tattered coat fluttering in the wind. A lone figure emerges, eyes gleaming with secrets untold. 
A lone figure emerges, cloaked in mystery and shadow. A lone figure emerges with footsteps echoing against the stone. A lone figure emerges, pausing to gaze up at the tower's peak.
 A lone figure emerges, cloaked in mystery and shadow. A lone figure emerges, clutching an old, worn-out map. A lone figure emerges, as if searching for something long lost. 
 A lone figure emerges, cloaked in mystery and shadow. A lone figure emerges, and his breath is visible in the cold night air. A lone figure emerges, carrying the weight of a forgotten 
 promise.

The wind picks up, carrying the scent of rain and pine. The wind picks up, howling through the narrow alleys. The wind picks up, as if itâ€™s trying to whisper something important.
 The wind picks up, carrying the scent of rain and pine. The wind picks up, rustling the papers scattered on the ground. The wind picks up, swirling around the figure in a gentle embrace.
  The wind picks up, carrying the scent of rain and pine. The wind picks up, tugging at the corners of his map. The wind picks up, echoing a song only he can hear. The wind picks up,
   carrying the scent of rain and pine. The wind picks up, as the clouds gather overhead. The wind picks up, carrying the past and present in a single gust.

The figure pauses, looking up at the clock tower one last time. The figure pauses, tracing the map with a gloved finger. The figure pauses, as if the answer lies within the shadows.
 The figure pauses, looking up at the clock tower one last time. The figure pauses, feeling the weight of the years upon him. The figure pauses, ready to face whatever lies ahead. 
 The figure pauses, looking up at the clock tower one last time. The figure pauses, and the world holds its breath. The figure pauses, and then steps forward into the unknown.
  The figure pauses, looking up at the clock tower one last time. The figure pauses, as the clock strikes midnight. The figure pauses, ready to uncover the mystery of the night.

And so, under the watchful gaze of the tower, the figure continues on. The figure continues on, as the lanterns flicker and fade. The figure continues on, with the wind guiding
 his every step. And so, under the watchful gaze of the tower, the figure continues on. The figure continues on, disappearing into the misty horizon. The figure continues on, chasing 
 the story that the night hides. And so, under the watchful gaze of the tower, the figure continues on. The figure continues on, until only his shadow remains. The figure continues on,
  becoming one with the legend of the town. And so, under the watchful gaze of the tower, the figure continues on. The figure continues on, leaving only echoes in his wake.
   The figure continues on, as the story begins anew.
    `;

    // Split the paragraph into lines
    const lines = paragraphText.split("\n");
    const lineHeight = 140;
    const x = canvas.width / 2;
    let y = canvas.height / 2 - (lines.length / 2) * lineHeight;

    lines.forEach((line) => {
      context.fillText(line.trim(), x, y);
      y += lineHeight;
    });


    const texture = new CanvasTexture(canvas);
    texture.anisotropy = 16; // Higher quality
texture.minFilter = THREE.LinearMipMapLinearFilter;
texture.magFilter = THREE.LinearFilter;
texture.wrapS = THREE.ClampToEdgeWrapping;
texture.wrapT = THREE.ClampToEdgeWrapping;
texture.needsUpdate = true; 

    return new THREE.CanvasTexture(canvas);
  };

  const textTexture = useMemo(() => createTextTexture(), []);

  
  const MailRef = useRef();
  const InstaRef= useRef()
  const PhotoRef= useRef()
  const SafariRef= useRef()
  const [mailHovered, setMailHovered] = useState(false);
  const [instaHovered, setInstaHovered] = useState(false);
  const [safariHovered, setSafariHovered] = useState(false);
  const [photoHovered, setPhotoHovered] = useState(false);

  // Rotate the sphere slowly
  useFrame(() => {
    if (MailRef.current) {
      const targetScale = mailHovered ? new THREE.Vector3(1.2, 1.2, 1) : new THREE.Vector3(1, 1, 1);
      MailRef.current.scale.lerp(targetScale, 0.1);
    }
    if (InstaRef.current) {
      const targetScale = instaHovered ? new THREE.Vector3(1.2, 1.2, 1) : new THREE.Vector3(1, 1, 1);
      InstaRef.current.scale.lerp(targetScale, 0.1);
    }
    if (SafariRef.current) {
      const targetScale = safariHovered ? new THREE.Vector3(1.2, 1.2, 1) : new THREE.Vector3(1, 1, 1);
      SafariRef.current.scale.lerp(targetScale, 0.1);
    }
    if (PhotoRef.current) {
      const targetScale = photoHovered ? new THREE.Vector3(1.2, 1.2, 1) : new THREE.Vector3(1, 1, 1);
      PhotoRef.current.scale.lerp(targetScale, 0.1);
    }
    
  });

 

  return (
    <Sphere ref={sphereRef} args={[2, 128, 128]} position={[0, 0, 0]}>
      <meshStandardMaterial
        // color={"green"}
        metalness={0}
        roughness={0}
        emissiveMap={textTexture}
        map={bgtexture}
        emissive={"white"}
        transparent
        opacity={0.8}
      />
       <Decal
      position={[0, 0.09, 2]}
      scale={MailScale}
      rotation={[0, 0, 0]}
      map={Mailtexture}
      depthWrite={true}
      polygonOffset={true}
      polygonOffsetFactor={-4}
      onPointerOver={() => {
        setMailHovered(true);
        // console.log('mail hovered');
      }}
      onPointerOut={() => {
        setMailHovered(false);
        // console.log('mail unhovered');
      }}
      ref={MailRef}
    />
       <Decal
      position={[0.19, 0.09, 2]}
      scale={InstaScale}
      rotation={[0, 0, 0]}
      map={Instatexture}
      depthWrite={true}
      polygonOffset={true}
      polygonOffsetFactor={-4}
      onPointerOver={() => {
        setInstaHovered(true);
        // console.log('Insta hovered');
      }}
      onPointerOut={() => {
        setInstaHovered(false);
        // console.log('Insta unhovered');
      }}
      ref={InstaRef}
    />
      <Decal
        position={[0.35, 0.09, 2]}
        scale={PhotoScale}
        rotation={[0,0,0]}
        map={Phototexture}
        // depthTest={true}
        depthWrite={true}
        polygonOffset={true}
        polygonOffsetFactor={-4}
        onPointerOver={() => setPhotoHovered(true)}
        onPointerOut={() => setPhotoHovered(false)}
        ref={PhotoRef}
   
      />
      <Decal
        position={[-0.19, 0.09, 2]}
        scale={SafariScale}
        rotation={[0,0,0]}
        map={Safaritexture}
        // depthTest={true}
        depthWrite={true}
        polygonOffset={true}
        polygonOffsetFactor={-4}
        onPointerOver={() => setSafariHovered(true)}
        onPointerOut={() => setSafariHovered(false)}
        ref={SafariRef}
      
      />
    </Sphere>
  );
};

const NewSphere = () => {
    const [loading, setLoading] = useState(true);

  useEffect(() => {
    const timer = setTimeout(() => {
      setLoading(false);
    }, 2000);

    return () => clearTimeout(timer);
  }, []);
    const getResponsiveStyles = () => {
        let styles = {
          position: "absolute",
          zIndex: 10,
          borderRadius: "38px",
          height: "81.5vh",
          top: "46.5%",
          left: "50%",
          transform: "translate(-50%, -50%)",
        };
      
        switch (true) {
          case window.innerHeight < 400:
            styles.width = "148px";
           // styles.borderRadius = "62px";
            break;
          case window.innerHeight < 410:
            styles.width = "150px";
           // styles.borderRadius = "62px";
            break;
          case window.innerHeight < 440:
            styles.width = "158px";
           // styles.borderRadius = "62px";
            break;
          case window.innerHeight < 460:
            styles.width = "167px";
           // styles.borderRadius = "62px";
            break;
          case window.innerHeight <= 479:
            styles.width = "175px";
           // styles.borderRadius = "62px";
            break;
          case window.innerHeight <= 510:
            styles.width = "186px";
           // styles.borderRadius = "62px";
            break;
          case window.innerHeight <= 556:
            styles.width = "206px";
           // styles.borderRadius = "62px";
            break;
          case window.innerHeight <= 605:
            styles.width = "237px";
           // styles.borderRadius = "62px";
            break;
          case window.innerHeight <= 658:
            styles.width = "255px";
           // styles.borderRadius = "62px";
            break;
          case window.innerHeight <= 705:
            styles.width = "265px";
           // styles.borderRadius = "62px";
            break;
          case window.innerHeight <= 750:
            styles.width = "287px";
           // styles.borderRadius = "62px";
            break;
          case window.innerHeight <= 785:
            styles.width = "295px";
           // styles.borderRadius = "47px";
            break;
          case window.innerHeight < 800:
            styles.width = "297px";
           // styles.borderRadius = "44px";
            break;
          case window.innerHeight < 828:
            styles.width = "311px";
           // styles.borderRadius = "47px";
            break;
          case window.innerHeight < 875:
            styles.width = "330px";
           // styles.borderRadius = "47px";
            break;
          case window.innerHeight < 907:
            styles.width = "354px";
           // styles.borderRadius = "62px";
            break;
          case window.innerHeight < 966:
            styles.width = "363px";
           // styles.borderRadius = "49px";
            break;
          case window.innerHeight < 1015:
            styles.width = "384px";
           // styles.borderRadius = "62px";
            break;
          case window.innerHeight < 1050:
            styles.width = "398px";
           // styles.borderRadius = "68px";
            break;
          case window.innerHeight < 1085:
            styles.width = "400px";
           // styles.borderRadius = "61px";
            break;
          default:
            styles.width = "427px";
           // styles.borderRadius = "80px";  // Fallback for other cases
            break;
        }
      
        // Optionally, you can include width-based responsiveness here as well, as per your initial code
        // if (window.innerWidth < 500) {
        //   styles.width = "348.2px";
        // } else if (window.innerWidth < 768) {
        //   styles.width = "15.5%";
        // } else if (window.innerWidth < 1200) {
        //   styles.width = "357px";
        // } else {
        //   styles.width = "357px";
        // }
      
        return styles;
      };
      
      const [responsiveStyles, setResponsiveStyles] = useState(getResponsiveStyles());
      
      useEffect(() => {
        const handleResize = () => {
          setResponsiveStyles(getResponsiveStyles());
        };
      
        window.addEventListener('resize', handleResize);
        return () => window.removeEventListener('resize', handleResize);
      }, []);
      
  return (
    <div>
{loading ? (<Loader/>) : ( <Canvas
      style={responsiveStyles}
      camera={{ position: [0, 0, 10], fov: 3 }}
      >
      <ambientLight intensity={1} />
      <directionalLight position={[10, 10, 5]} intensity={1.5} />
      <Environment preset="city" background={false} /> 
      <color attach="background" args={["lightblue"]} />
      <DecalOnSphere />
      <OrbitControls 
      minDistance={19} maxDistance={28}
       />
    </Canvas>)}
   
        </div>
  );
};

export default NewSphere;

BTN:

import React, { useState } from 'react'


const Btn = ({endLoading}) => {
  const [open, setOpen] = useState(false)
  // max-sm:w-[76%] 19
  // absolute z-20 rounded-[38px] left-[40.5%] top-[5%] w-[287px] max-sm:left-[12.2%]  h-[83vh]
  return (
    <div className='back  flex  items-center justify-center'>
      {/* <div className='GG'></div> */}
      <div className='' >
   
<button onClick={endLoading} className='bg-black text-white w-36  h-12 rounded-xl font-bold font-[CustomFont] text-lg'>
  Get Started
</button>


      </div>

   
    </div>
  )
}

export default Btn

IPHONE TASK:
import { Canvas } from "@react-three/fiber";
import React from "react";

import { Html, OrbitControls, useGLTF } from "@react-three/drei";
import { Iphone } from "./Phone";


const ITask = () => {
  return (
    <div className=" bg-blue-400">
      <Canvas
        style={{
          height: "100vh",
          width: "100vw",
          position: "absolute",
          zIndex: 5,
        }}
        camera={{
          position: [0, 0, 6],
          fov: 1.8,
        }}
      >
        <color attach="background" args={["#42A5F5"]} />
        <OrbitControls enableRotate={false} enableZoom={false} />
        <ambientLight intensity={1.5} />

        <Iphone scale={1} metalness={1} position={[0.015, 0, 0]} roghness={0} />
      </Canvas>
    </div>
  );
};

export default ITask;

HOME:
import React, { useState } from 'react'
import BSPhere from './BSPhere'
import Btn from './Btn'
import ITask from './ITask'
import NewSphere from './BSPhere'



const TaskSix = () => {
    
        const [open, setOpen] = useState(true)
      
        const handleBtn = () =>{
          setOpen(false)
        }
  return (
    <div className='bg-[#42A5F5]' style={{ position: "relative", height: "100vh", width: "100vw" }}>
      {open ? <Btn endLoading={handleBtn}/> : <NewSphere style={{ position: "absolute", top: 20, left: 0, zIndex: 10 }}/> }
     
      <ITask style={{ position: "absolute", top: 0, left: 0, zIndex: 5 }}/>
    </div>
  )
}

export default TaskSix



-----------------------------Task Five--------------------------------------------
import { Environment, Html, OrbitControls } from '@react-three/drei'
import { Canvas, useFrame, useThree } from '@react-three/fiber'
import { useSpring } from '@react-spring/three';
import React, { useEffect, useRef, useState } from 'react'

import { Icon } from '@iconify/react/dist/iconify.js';
import { CanvasTexture, LinearFilter } from 'three';
import { BlockPicker } from 'react-color';
import { Sphere } from './Sphere';

const degToRad = (degrees) => degrees * (Math.PI / 180);



const createTextTexture = (text, heading, buttonText, headingColor, textColor, buttonColor) => {
  const canvas = document.createElement('canvas');
  canvas.width = 4300; // Adjust this to control the resolution
  canvas.height = 2080; // Adjust this to control the resolution
  const context = canvas.getContext('2d');

  // Background
  context.fillStyle = 'white';
  context.fillRect(0, 0, canvas.width, canvas.height);

  // Check if the screen height is greater than 600px
  context.translate(canvas.width, 0);
  context.scale(-1, 1); // Apply mirror effect
  if (window.innerWidth > 600) {
}

  // Heading
  context.font = '60px Arial';
  context.fillStyle = headingColor;
  context.textAlign = 'center';
  context.textBaseline = 'left';
  context.lineJoin = 'round';
  context.miterLimit = 2;
  context.fillText(heading, canvas.width / 2, 200);
  context.fillText(heading, canvas.width / 2, 300);
  context.fillText(heading, canvas.width / 2, 400);

  // Additional text
  const additionalText = heading;
  const someData = "am doloribus eos assumenda soluta iusto fugit perspiciatis quo, vitae vel sed";
  context.font = 'normal 90px Arial';
  context.fillStyle = headingColor;
  context.textAlign = 'left';
  context.textBaseline = 'ideographic';

  let yPosition = 50;
  const lineHeight = 100; 

  // Button
  const buttonWidth = 0; // Adjusted width
  const buttonHeight = 0; // Adjusted height
  const buttonX = (canvas.width / 2) - (buttonWidth / 2);
  const buttonY = 400; // Adjusted y-position

  context.fillStyle = buttonColor;
  context.fillRect(buttonX, buttonY, buttonWidth, buttonHeight);
  context.font = 'bold 80px Arial'; // Larger font size
  context.fillStyle = headingColor;
  context.fillText(buttonText, canvas.width / 2, buttonY + (buttonHeight / 2));

  // Paragraph
  context.font = '80px Arial'; // Larger font size
  context.fillStyle = headingColor;
  context.textAlign = 'center';

  const words = text.split(' ');
  let line = '';
  let y = buttonY + buttonHeight + 1; // Adjusted y-position
  const someHeight = 100; // Increased line height

  words.forEach((word) => {
    const testLine = `${line}${word} `;
    const metrics = context.measureText(testLine);
    const testWidth = metrics.width;
    if (testWidth > canvas.width + 40 && line !== '') {
      context.fillText(line, canvas.width / 2, y);
      line = `${word} `;
      y += someHeight;
    } else {
      line = testLine;
    }
  });
  context.fillText(line, canvas.width / 2, y);

  const texture = new CanvasTexture(canvas);
  texture.anisotropy = 16; // Increase anisotropy for better quality at an angle
  texture.minFilter = LinearFilter; // Use linear filter for smoother appearance
  texture.magFilter = LinearFilter; // Use linear filter for smoother appearance
  texture.generateMipmaps = false; // Disable mipmaps if text appears blurry

  return texture;
};



const CameraController = ({ cameraPosition }) => {
  const { camera } = useThree();
  const { position } = useSpring({ position: cameraPosition });

  useEffect(() => {
    camera.position.set(...position.get());
    camera.updateProjectionMatrix();
  }, [position, camera]);

  return null;
};

const Controls = ({ isLimitedZoom, currentDistanceRef, initialDistance, zoomLocked }) => {
  const controlsRef = useRef();
  const { camera } = useThree();
  const [initialPositionSet, setInitialPositionSet] = useState(false);
  const zoomLimitsSetRef = useRef(false);

  useEffect(() => {
    if (!initialPositionSet) {
      camera.position.set(0, 0, initialDistance);
      setInitialPositionSet(true);
    }
  }, [camera, initialDistance, initialPositionSet]);

  useEffect(() => {
    if (controlsRef.current) {
      controlsRef.current.enabled = !zoomLocked;
      controlsRef.current.update();
    }
  }, [zoomLocked]);

  useEffect(() => {
    if (controlsRef.current) {
      const currentDistance = currentDistanceRef.current;

      if (isLimitedZoom && !zoomLimitsSetRef.current) {
        if (currentDistance <= 5) {
          controlsRef.current.minDistance = currentDistance - 1;
          controlsRef.current.maxDistance = currentDistance + 1.10;
        } else {
          controlsRef.current.minDistance = currentDistance - 5;
          controlsRef.current.maxDistance = currentDistance + 5;
        }
        zoomLimitsSetRef.current = true;
        console.log(`Min Distance: ${controlsRef.current.minDistance}, Max Distance: ${controlsRef.current.maxDistance}`);
      } else if (!isLimitedZoom) {
        controlsRef.current.minDistance = 2;
        controlsRef.current.maxDistance = 4.5;
        zoomLimitsSetRef.current = false;
        console.log(`Zoom limits reset: Min Distance: ${controlsRef.current.minDistance}, Max Distance: ${controlsRef.current.maxDistance}`);
      } 

      controlsRef.current.update();
    }
  }, [isLimitedZoom]);
  useFrame(() => {
    if (controlsRef.current) {
      const currentDistance = controlsRef.current.object.position.distanceTo(controlsRef.current.target);
      currentDistanceRef.current = currentDistance;
    }
  });

  return <OrbitControls ref={controlsRef} enableZoom />;
};


const TaskFive = () => {
  const [heading, setHeading] = useState('onsectetur adipisicing elit. Possimus aperiam hic sapiente, eos assumenda soluta iusto fugit perspiciatis quo, vitae vel sed. Harum eveniet sequi ut laudantium iure. Lorem  sapiente, quam doloribus eos assumenda soluta iusto fugit perspiciatis quo, vitae vel sed. Harum eveniet sequi ut laudantium iure.');
  
  const [text, setText] = useState('TLorem ipsum dolor sit amet, consectetur adipiscing elit.  do eiusmod tempor incididunt ut labore et dolore maga aliqua.  Lorem ipsum dolor sit amet consectetur adipisicing elit. Possimus aperiam hic sapiente, quam doloribus eos assumenda soluta iusto fugit perspiciatis quo, vitae vel sed. Harum eveniet sequi ut laudantium iure. Lorem ipsum dolor sit amet consectetur adipisicing elit. Possimus aperiam hic sapiente, quam doloribus eos assumenda soluta iusto fugit perspiciatis quo, vitae vel sed. Harum eveniet sequi ut laudantium iure. Lorem ipsum dolor sit amet consectetur adipisicing elit. Possimus aperiam hic sapiente, quam doloribus eos assumenda soluta iusto fugit perspiciatis quo, vitae vel sed. Harum eveniet sequi ut laudantium iure. Lorem ipsum dolor sit amet consectetur adipisicing elit. Possimus aperiam hic sapiente, quam doloribus eos assumenda soluta iusto fugit perspiciatis quo, vitae vel sed. Harum eveniet sequi ut laudantium iure. Lorem ipsum  Lorem ipsum dolor sit  perspiciatis quo, vitae vel sed. Harum eveniet sequi ut laudantium iure. Lorem ipsum dolor sit amet consectetur adipisicing elit. Possimus aperiam hic sapiente, quam doloribus eos assumenda soluta iusto fugit perspiciatis quo, vitae vel sed. Harum eveniet sequi ut laudantium iure. Lorem ipsum  Lorem ipsum dolor sit  perspiciatis quo, vitae vel sed. Harum eveniet sequi ut laudantium iure. Lorem ipsum dolor sit amet consectetur adipisicing elit. Possimus aperiam hic sapiente, quam doloribus eos assumenda soluta iusto fugit perspiciatis quo, vitae vel sed. Harum eveniet sequi ut laudantium iure. Lorem ipsum  Lorem ipsum dolor sit  perspiciatis quo, vitae vel sed. Harum eveniet sequi ut laudantium iure. Lorem ipsum dolor sit amet consectetur adipisicing elit. Possimus aperiam hic sapiente, quam doloribus eos assumenda soluta iusto fugit perspiciatis quo, vitae vel sed. Harum eveniet sequi ut laudantium iure. Lorem ipsum  Lorem ipsum dolor sit  perspiciatis quo, vitae vel sed. Harum eveniet sequi ut laudantium iure. Lorem ipsum dolor sit amet consectetur adipisicing elit. Possimus aperiam hic sapiente, quam doloribus eos assumenda soluta iusto fugit perspiciatis quo, vitae vel sed. Harum eveniet sequi ut laudantium iure. Lorem ipsum  Lorem ipsum dolor sit amet consectetur adipisicing elit. Possimus aperiam hic sapiente, quam doloribus eos assumenda soluta iusto fugit perspicia Lorem ipsum dolor sit amet consectetur adipisicing elit. Possimus aperiam hic sapiente, quam doloribus eos assumenda soluta iusto fugit perspiciatis quo, vitae vel sed. Harum eveniet sequi ut laudantium iure. Lorem ipsum dolor sit amet consectetur adipisicing elit. Possimus aperiam hic sapiente, quam doloribus eos assumenda soluta iusto fugit perspiciatis quo, vitae vel sed. Harum eveniet sequi ut laudantium iure. Lorem ipsum dolor sit amet consectetur adipisicing elit. Possimus aperiam hic sapiente, quam doloribus eos assumenda soluta iusto fugit perspiciatis quo, vitae vel sed. Harum eveniet sequi ut laudantium iure. Lorem ipsum dolor sit amet consectetur adipisicing elit. Possimus aperiam hic sapiente, quam doloribus eos assumenda soluta iusto fugit perspiciatis quo, vitae vel sed. Harum eveniet sequi ut laudantium iure.a soluta iusto fugit perspiciatis quo, vitae vel sed. Harum eveniet sequi ut laudantium iure. dolor sit amet consectetur adipisicing elit. Possimus aperiam hic sapiente, quam doloribus eos assumenda soluta iusto fugit perspiciatis quo, vitae vel sed. Harum eveniet sequi ut laudantium iure');
  const [rotateX, setRotateX] = useState(10.01);
  const [rotateY, setRotateY] = useState(90);
  const [color, setColor] = useState('#FFFFFF');
  const [textColor, setTextColor] = useState('#000000');
  const [headingColor, setHeadingColor] = useState('#000000'); // Initial color for heading
const [buttonColor, setButtonColor] = useState('#ff0000'); // Initial 
const rotateIntervalRef = useRef(null);
  const [cameraPosition, setCameraPosition] = useState([0, 0, 3]);
  const [zoomLocked, setZoomLocked] = useState(false);
  const [isLimitedZoom, setIsLimitedZoom] = useState(false);
  const currentDistanceRef = useRef(3); // Default initial distance
  const initialDistance = 3;
  const [envPreset, setEnvPreset] = useState('dawn');
  const [environmentActive, setEnvironmentActive] = useState(false);
  const [mobile, setmobile] = useState(false);
  useEffect(() => {
    const mediaQuery = window.matchMedia("(max-width:600px)");
    setmobile(mediaQuery.matches);

    const handleMediaQuaryChange = (event) => {
      setmobile(event.matches);
      console.log('Media query matched:', event.matches); // Debug log
      console.log('Current mobile state:', mobile);  
      
      
    };
    mediaQuery.addEventListener("change", handleMediaQuaryChange);

    return () => {
      mediaQuery.removeEventListener("change", handleMediaQuaryChange);
    };
  }, []);

  useEffect(() => {
    console.log('Updated mobile state:', mobile);
  }, [mobile]);
  const toggleLimitedZoom = () => {
    setIsLimitedZoom((prev) => !prev);
  };
  const startRotation = (direction) => {
    if (rotateIntervalRef.current) {
      clearInterval(rotateIntervalRef.current);
    }

    rotateIntervalRef.current = setInterval(() => {
      switch (direction) {
        case 'left':
          setRotateY((prevRotateY) => prevRotateY - degToRad(1));
          break;
        case 'right':
          setRotateY((prevRotateY) => prevRotateY + degToRad(1));
          break;
        case 'up':
          setRotateX((prevRotateX) => prevRotateX - degToRad(1));
          break;
        case 'down':
          setRotateX((prevRotateX) => prevRotateX + degToRad(1));
          break;
        default:
          break;
      }
    }, 40);
  };
  const handleEnvPresetChange = (e) => {
    if (e.target.value === 'default') {
      setEnvironmentActive(!environmentActive);
    } else {
      setEnvPreset(e.target.value);
    }
  };
  const stopRotation = () => {
    if (rotateIntervalRef.current) {
      clearInterval(rotateIntervalRef.current);
    }
  };

  const handleColorChange = (color) => {
    setColor(color.hex);
  };

  const handleHeadingColorChange = (color) => {
    setHeadingColor(color.hex);
};

  return (
   <Canvas camera={{ position: [0, 0, 0.1], fov: 10 }} style={{height:"100vh"}}>
     <CameraController cameraPosition={cameraPosition} />
   <Controls 
          isLimitedZoom={isLimitedZoom}
          currentDistanceRef={currentDistanceRef}
          initialDistance={initialDistance}
          zoomLocked={zoomLocked}
        />
        <Html>
          <div >

          <div className='flex max-sm:left-0 max-sm:-top-[135px] max-sm:gap-0 max-sm: space-x-1 absolute bottom-48 left-[550px] transform -translate-x-1/2'>
            <div>
              <button
                onMouseDown={() => startRotation('up')}
                onMouseUp={stopRotation}
                onMouseLeave={stopRotation}
                className="relative overflow-hidden rounded-lgmax-sm:rounded-none max-sm:hidden h-12 max-sm:h-5 group hover:shadow-lg hover:scale-105 transition duration-500 before:absolute  before:inset-0 before:rounded-lg before:bg-gradient-to-br before:from-pink-400 before:via-purple-400 before:to-indigo-400"
              >
                <span className="relative  flex items-center text-white font-bold
     max-sm:text-sm px-4 max-sm:px-1 py-2 max-sm:py-0">Up</span>
              </button>
            </div>
            <button
              onMouseDown={() => startRotation('left')}
              onMouseUp={stopRotation}
              onMouseLeave={stopRotation}
              className="relative overflow-hidden rounded-lgmax-sm:rounded-none max-sm:hidden  h-12 max-sm:h-5 group hover:shadow-lg hover:scale-105 transition duration-500 before:absolute  before:inset-0 before:rounded-lg before:bg-gradient-to-br before:from-pink-400 before:via-purple-400 before:to-indigo-400"
            >
              <span className="relative flex items-center text-white font-bold
     max-sm:text-sm px-4 max-sm:px-1 py-2 max-sm:py-0">Left</span>
            </button>
            <button
              onMouseDown={() => startRotation('down')}
              onMouseUp={stopRotation}
              onMouseLeave={stopRotation}
              className="relative overflow-hidden rounded-lgmax-sm:rounded-none max-sm:hidden  h-12 max-sm:h-5 group hover:shadow-lg hover:scale-105 transition duration-500 before:absolute  before:inset-0 before:rounded-lg before:bg-gradient-to-br before:from-pink-400 before:via-purple-400 before:to-indigo-400"
            >
              <span className="relative flex items-center text-white font-bold
     max-sm:text-sm px-4 max-sm:px-1 py-2 max-sm:py-0">Down</span>
            </button>
            <button
              onMouseDown={() => startRotation('right')}
              onMouseUp={stopRotation}
              onMouseLeave={stopRotation}
              className="relative overflow-hidden rounded-lgmax-sm:rounded-none max-sm:hidden  h-12 max-sm:h-5 group hover:shadow-lg hover:scale-105 transition duration-500 before:absolute  before:inset-0 before:rounded-lg before:bg-gradient-to-br before:from-pink-400 before:via-purple-400 before:to-indigo-400"
            >
              <span className="relative flex items-center text-white font-bold
     max-sm:text-sm px-4 max-sm:px-1 py-2 max-sm:py-0">Right</span>
            </button>
          </div>

          <div className='flex max-sm:flex-col max-sm:justify-center max-sm:-right-[135px] max-sm:gap-2 max-sm:-bottom-20 items-center bottom-48 -right-[429px] space-x-8 absolute transform -translate-x-1/2 p-4 rounded'>
            <div className="relative group">
              <button className="relative overflow-hidden rounded-lgmax-sm:rounded-none max-sm:hidden  h-12 max-sm:h-5 group hover:shadow-lg hover:scale-105 transition duration-500 before:absolute  before:inset-0 before:rounded-lg before:bg-gradient-to-br before:from-pink-400 before:via-purple-400 before:to-indigo-400">
                <span className="relative flex items-center text-white font-bold
     max-sm:text-sm px-4 max-sm:px-1 py-2 max-sm:py-0">Color <Icon className='mx-1' icon="pepicons-print:color-picker" /></span>
              </button>
              <div className="absolute z-10 hidden group-hover:block  p-2 bg-white border border-gray-300 rounded shadow-lg">
                <BlockPicker  className="custom-sketch-picker" 
  
        color={color} onChangeComplete={handleColorChange} />
              </div>
            </div>
            <select value={envPreset} onChange={handleEnvPresetChange} className="inline-flex mt-2 p-2 w-28 max-sm:hidden border border-slate-300 rounded focus:outline-none focus:ring-1 focus:ring-slate-300">
              <option value="default">Default</option>
              <option value="city">City</option>
              <option value="sunset">Sunset</option>
              <option value="dawn">Dawn</option>
              <option value="night">Night</option>
              <option value="forest">Forest</option>
              <option value="apartment">Apartment</option>
              <option value="studio">Studio</option>
              <option value="warehouse">Warehouse</option>
              <option value="park">Park</option>
              <option value="lobby">Lobby</option>
            </select>
            <div className="relative group">
  <button className="relative overflow-hidden rounded-lgmax-sm:rounded-none max-sm:hidden  h-12 max-sm:h-5 group hover:shadow-lg hover:scale-105 transition duration-500 before:absolute  before:inset-0 before:rounded-lg before:bg-gradient-to-br before:from-pink-400 before:via-purple-400 before:to-indigo-400">
    <span className="relative flex items-center text-white font-bold
     max-sm:text-sm px-4 max-sm:px-1 py-2 max-sm:py-0">
      Text <Icon className='mx-1' icon="pepicons-print:color-picker" />
    </span>
  </button>
  <div className="absolute z-10 hidden group-hover:block  p-2 bg-white border border-gray-300 rounded shadow-lg">
    <BlockPicker className="custom-sketch-picker" color={headingColor} onChangeComplete={handleHeadingColorChange} />
  </div>
</div>
<div className="relative group">

  
</div>
            <button
              onClick={toggleLimitedZoom}
              className="relative overflow-hidden rounded-lgmax-sm:rounded-none max-sm:hidden  h-12 max-sm:h-5 group hover:shadow-lg hover:scale-105 transition duration-500 before:absolute  before:inset-0 before:rounded-lg before:bg-gradient-to-br before:from-pink-400 before:via-purple-400 before:to-indigo-400"
            >
              <span className="relative flex items-center text-white font-bold
     max-sm:font-light max-sm:text-sm px-4 max-sm:px-1 py-2 max-sm:py-0">
              {isLimitedZoom ? <Icon className='h-[30px] max-sm:h-[10px]'  icon="material-symbols:lock" /> : <Icon className='h-[30px] max-sm:h-[10px]' icon="bi:unlock-fill" />}
              </span>
            </button>
          </div>

          </div>
        </Html>
        <color attach="background" args={["#87CEEB"]} />
        {environmentActive && <Environment preset={envPreset} background={false} />}
 <Sphere text={text} headingColor={headingColor}
  buttonColor={buttonColor} createTextTexture={createTextTexture} heading={heading}  textColor={textColor}  position={[0, 0.1, 0]}
   rotateX={rotateX} rotateY={rotateY} mobile={mobile} color={color}
     />
             <ambientLight intensity={1.5}/>
   </Canvas>
  )
}

export default TaskFive

----------------------------------current task------------------------------------
import {
  Decal,
  Environment,
  Html,
  OrbitControls,
  Text,
} from "@react-three/drei";
import { Canvas, useFrame, useLoader, useThree } from "@react-three/fiber";
import React, { useState, useEffect, useRef, useMemo, Suspense } from "react";
import { useSpring } from "@react-spring/three";
import { TextureLoader, CanvasTexture, LinearFilter } from "three";
import * as THREE from "three";

import { Leva, useControls } from "leva";
import Loader from "./TaskSix/Loader";
import { Sphere } from "./Sphere";

const degToRad = (degrees) => degrees * (Math.PI / 180);

const createTextTexture = (
  text,
  heading,
  buttonText,
  headingColor,
  textColor,
  buttonColor
) => {
  const canvas = document.createElement("canvas");
  canvas.width = 4300; // Adjust this to control the resolution
  canvas.height = 2080; // Adjust this to control the resolution
  const context = canvas.getContext("2d");

  // Background
  context.fillStyle = "white";
  context.fillRect(0, 0, canvas.width, canvas.height);

  // Heading
  context.font = "bold 150px Arial";
  context.fillStyle = headingColor;
  context.textAlign = "center";
  context.textBaseline = "middle";
  context.lineJoin = "round";
  context.miterLimit = 2;
  context.fillText(heading, canvas.width / 2, 200);

  // Button
  const buttonWidth = 800; // Adjusted width
  const buttonHeight = 200; // Adjusted height
  const buttonX = canvas.width / 2 - buttonWidth / 2;
  const buttonY = 400; // Adjusted y-position

  context.fillStyle = buttonColor;
  context.fillRect(buttonX, buttonY, buttonWidth, buttonHeight);
  context.font = "bold 80px Arial"; // Larger font size
  context.fillStyle = textColor;
  context.fillText(buttonText, canvas.width / 2, buttonY + buttonHeight / 2);

  // Paragraph
  context.font = "50px Arial"; // Larger font size
  context.fillStyle = textColor;
  context.textAlign = "center";

  const words = text.split(" ");
  let line = "";
  let y = buttonY + buttonHeight + 100; // Adjusted y-position
  // let x = buttonX + buttonHeight + 0; // Adjusted y-position
  const lineHeight = 100; // Increased line height

  words.forEach((word) => {
    const testLine = `${line}${word} `;
    const metrics = context.measureText(testLine);
    const testWidth = metrics.width;
    if (testWidth > canvas.width - 40 && line !== "") {
      context.fillText(line, canvas.width / 2, y);
      line = `${word} `;
      y += lineHeight;
    } else {
      line = testLine;
    }
  });
  context.fillText(line, canvas.width / 2, y);

  const texture = new CanvasTexture(canvas);
  texture.anisotropy = 16; // Increase anisotropy for better quality at an angle
  texture.minFilter = LinearFilter; // Use linear filter for smoother appearance
  texture.magFilter = LinearFilter; // Use linear filter for smoother appearance
  texture.generateMipmaps = false; // Disable mipmaps if text appears blurry

  return texture;
};

const BoxGeometry = ({
  text,
  mobile,
  heading,
  buttonText,
  headingColor,
  buttonColor,
  textColor = "black",
  color = "orange",
  position,
  rotateX,
  rotateY,
}) => {
  const texture = useMemo(() => {
    return createTextTexture(
      text,
      heading,
      buttonText,
      headingColor,
      textColor,
      buttonColor
    );
  }, [text, heading, buttonText, headingColor, textColor, buttonColor]);

  const SafariRef = useRef();

  // const [safariHovered, setSafariHovered] = useState(false);
  const [safariClicked, setSafariClicked] = useState(false);

  const Safaritexture = useLoader(THREE.TextureLoader, "/images/safaris.png");

  useFrame(() => {
    const targetScales = {
      Safari: safariClicked
        ? new THREE.Vector3(1.2, 1.2, 1)
        : new THREE.Vector3(1, 1, 1),
    };

    SafariRef.current.scale.lerp(targetScales.Safari, 0.1);
  });

  useEffect(() => {
    const timeoutDuration = 1 * 1000; // 2 minutes in milliseconds

    // Set timeout for photoClicked
    if (safariClicked) {
      const timer = setTimeout(() => {
        setSafariClicked(false);
      }, timeoutDuration);
      return () => clearTimeout(timer);
    }
  }, [safariClicked]);

  return (
    <mesh
      position={position}
      rotation={[rotateX, rotateY, 0]}
      scale={mobile ? 0.7 : 1}
    >
      <sphereGeometry args={[1, 63, 63]} />
      <meshStandardMaterial
        metalness={0}
        roughness={0}
        opacity={1}
        color={color}
        map={texture}
      />

      <Decal
        depthWrite
        polygonOffset
        ref={SafariRef}
        polygonOffsetFactor={-4}
        // onPointerOver={() => setSafariHovered(true)}
        // onPointerOut={() => setSafariHovered(false)}
        onClick={() => setSafariClicked(true)}
        position={[0, 0.601, 0.8]}
        rotation={[0, 0, 0]}
        scale={new THREE.Vector3(0.08, 0.08, 0.08)}
        map={Safaritexture}
      />
    </mesh>
  );
};

const CameraController = ({ cameraPosition }) => {
  const { camera } = useThree();
  const { position } = useSpring({ position: cameraPosition });

  useEffect(() => {
    camera.position.set(...position.get());
    camera.updateProjectionMatrix();
  }, [position, camera]);

  return null;
};

const Controls = ({
  isLimitedZoom,
  currentDistanceRef,
  initialDistance,
  zoomLocked,
}) => {
  const controlsRef = useRef();
  const { camera } = useThree();
  const [initialPositionSet, setInitialPositionSet] = useState(false);
  const zoomLimitsSetRef = useRef(false);

  useEffect(() => {
    if (!initialPositionSet) {
      camera.position.set(0, 0, initialDistance);
      setInitialPositionSet(true);
    }
  }, [camera, initialDistance, initialPositionSet]);

  useEffect(() => {
    if (controlsRef.current) {
      controlsRef.current.enabled = !zoomLocked;
      controlsRef.current.update();
    }
  }, [zoomLocked]);

  useEffect(() => {
    if (controlsRef.current) {
      const currentDistance = currentDistanceRef.current;

      if (isLimitedZoom && !zoomLimitsSetRef.current) {
        if (currentDistance <= 5) {
          controlsRef.current.minDistance = currentDistance - 1;
          controlsRef.current.maxDistance = currentDistance + 1.1;
        } else {
          controlsRef.current.minDistance = currentDistance - 5;
          controlsRef.current.maxDistance = currentDistance + 5;
        }
        zoomLimitsSetRef.current = true;
      } else if (!isLimitedZoom) {
        controlsRef.current.minDistance = 2;
        controlsRef.current.maxDistance = 45;
        zoomLimitsSetRef.current = false;
      }

      controlsRef.current.update();
    }
  }, [isLimitedZoom]);

  useFrame(() => {
    if (controlsRef.current) {
      const currentDistance = controlsRef.current.object.position.distanceTo(
        controlsRef.current.target
      );
      currentDistanceRef.current = currentDistance;
    }
  });

  return <OrbitControls ref={controlsRef} enableZoom />;
};

const CombinedController = ({ mode }) => {
  const { camera } = useThree();
  const meshRef = useRef();
  const horizontalAngleRef = useRef(0);
  const verticalAngleRef = useRef(0);
  const scrollXRef = useRef(0);
  const scrollYRef = useRef(0);
  const [lastTouch, setLastTouch] = useState({ x: 0, y: 0 });

  useEffect(() => {
    const handleScroll = (event) => {
      if (mode === "camera") {
        horizontalAngleRef.current += event.deltaX * 0.01;
        verticalAngleRef.current += event.deltaY * 0.01;
      } else if (mode === "object") {
        scrollXRef.current += event.deltaX * 0.01;
        scrollYRef.current += event.deltaY * 0.01;
      }
    };

    const handleTouchStart = (event) => {
      const touch = event.touches[0];
      setLastTouch({ x: touch.clientX, y: touch.clientY });
    };

    const handleTouchMove = (event) => {
      const touch = event.touches[0];
      const deltaX = touch.clientX - lastTouch.x;
      const deltaY = touch.clientY - lastTouch.y;
      if (mode === "camera") {
        horizontalAngleRef.current += deltaX * 0.01;
        verticalAngleRef.current += deltaY * 0.01;
      } else if (mode === "object") {
        scrollXRef.current += deltaX * 0.01;
        scrollYRef.current += deltaY * 0.01;
      }
      setLastTouch({ x: touch.clientX, y: touch.clientY });
    };

    window.addEventListener("wheel", handleScroll, { passive: true });
    window.addEventListener("touchstart", handleTouchStart, { passive: true });
    window.addEventListener("touchmove", handleTouchMove, { passive: true });

    return () => {
      window.removeEventListener("wheel", handleScroll);
      window.removeEventListener("touchstart", handleTouchStart);
      window.removeEventListener("touchmove", handleTouchMove);
    };
  }, [mode, lastTouch]);

  useFrame(() => {
    if (mode === "camera") {
      camera.position.x = Math.cos(horizontalAngleRef.current) * 3;
      camera.position.y = Math.sin(verticalAngleRef.current) * 3;
      camera.lookAt(0, 0, 0);
    } else if (mode === "object" && meshRef.current) {
      meshRef.current.rotation.y = scrollXRef.current;
      meshRef.current.rotation.x = scrollYRef.current;
    }
  });
  return null
};

const GGG = () => {
  const [cameraPosition, setCameraPosition] = useState([0, 0, 3]);
  const [buttonText, setButtonText] = useState("Click Me");
  const [heading, setHeading] = useState("Global Text");
  const [text, setText] = useState(
    "  Possimus aperiam hic sapiente, quam doloribus eos assumenda soluta iusto fugit perspiciatis quo, vitae vel sed. Harum eveniet sequi ut laudantium iure. Lorem ipsum itae vel sed. Harum eveniet sequi ut laudantium iure"
  );
  const [rotateX, setRotateX] = useState(0);
  const [rotateY, setRotateY] = useState(0);
  const [environmentActive, setEnvironmentActive] = useState(true);
  const [mobile, setMobile] = useState(false);
  const [zoomLocked, setZoomLocked] = useState(false);
  const [isLimitedZoom, setIsLimitedZoom] = useState(false);
  const currentDistanceRef = useRef(3);
  const initialDistance = 3;
  const [model, setModel] = useState(false);
  const [join, setJoin] = useState(false);
  const [scrollEnabled, setScrollEnabled] = useState(false);
  const [scrollMode, setScrollMode] = useState("camera"); // "camera" or "object"
  const sphereRef = useRef();
  // Leva controls
  const {
    Rotate_X,
    Rotate_Y,
    Object_Color,
    Text_Color,
    Heading_Color,
    Button_Color,
    Scroll_Enabled,
    Scroll_Mode,
    Environment_Preset,
    Zoom_Lock,
    Show_Environment,
    Limited_Zoom,
    Show_Model, // New toggle control for model
    Join_Model,
    // Text_Input, // Added control for text input
  } = useControls({
    Rotate_X: {
      value: 0,
      min: -360,
      max: 360,
      step: 1,
      onChange: (value) => setRotateX(degToRad(value)),
    },
    Rotate_Y: {
      value: 0,
      min: -360,
      max: 360,
      step: 1,
      onChange: (value) => setRotateY(degToRad(value)),
    },
    Text_Color: { value: "#000000" },
    Heading_Color: { value: "#000000" },
    Button_Color: { value: "#ff0000" },
    Object_Color: { value: "#754280" },
    Environment_Preset: {
      value: "lobby",
      options: [
        "apartment",
        "city",
        "dawn",
        "forest",
        "lobby",
        "night",
        "park",
        "studio",
        "sunset",
        "warehouse",
      ],
    },
    Zoom_Lock: {
      value: false,
      onChange: (value) => setZoomLocked(value),
    },
    Show_Environment: {
      value: true,
      label: "Show Environment",
    },
    Limited_Zoom: {
      value: false,
      label: "Limited Zoom",
      onChange: (value) => setIsLimitedZoom(value),
    },
    Text_Input: {
      value: text,
      label: "Edit Text",
      onChange: (value) => setText(value),
    },
    Show_Model: {
      // Add model control
      value: true,
      label: "Show Model",
      onChange: (value) => setModel(value),
    },
    Join_Model: {
      // Add model control
      value: false,
      label: "Join Model",
      onChange: (value) => setJoin(value),
    },Scroll_Enabled: {
      value: false,
      label: "Enable Scroll",
    },
    Scroll_Mode: {
      value: "camera",
      options: ["camera", "object"],
      label: "Scroll Mode",
    },
  });

  useEffect(() => {
    const mediaQuery = window.matchMedia("(max-width:500px)");
    setMobile(mediaQuery.matches);

    const handleMediaQueryChange = (event) => {
      setMobile(event.matches);
    };
    mediaQuery.addEventListener("change", handleMediaQueryChange);

    return () => {
      mediaQuery.removeEventListener("change", handleMediaQueryChange);
    };
  }, []);

  return (
    <div className="h-screen w-screen relative">
      <Leva />
      <Suspense fallback={<Loader />}>
        <Canvas
          gl={{ antialias: true }}
          camera={{ position: [0, 0, 10], fov: 40, near: 0.1, far: 1000 }}
        >
          <ambientLight intensity={1.5} />
          <CameraController cameraPosition={cameraPosition} />
          {Show_Environment && Environment_Preset !== "none" && (
            <Environment preset={Environment_Preset} background={false} />
          )}
          <color attach="background" args={["#64748b"]} />
           <Controls
            isLimitedZoom={isLimitedZoom}
            currentDistanceRef={currentDistanceRef}
            initialDistance={initialDistance}
            zoomLocked={zoomLocked}
          /> 
 {Scroll_Enabled && <CombinedController mode={Scroll_Mode} />}


          {join ? (
            <>
              <BoxGeometry
                text={text}
                ref={sphereRef}
                heading={heading}
                buttonText={buttonText}
                headingColor={Heading_Color}
                buttonColor={Button_Color}
                textColor={Text_Color}
                color={Object_Color}
                position={[0, 0, 0]}
                rotateX={rotateX}
                rotateY={rotateY}
                mobile={mobile}
              />
              <Sphere
                text={text}
                ref={sphereRef}
                headingColor={Heading_Color}
                buttonColor={Button_Color}
                createTextTexture={createTextTexture}
                heading={heading}
                textColor={Text_Color}
                position={[0, 0.1, 0]}
                rotateX={rotateX}
                rotateY={rotateY}
                mobile={mobile}
              />
            </>
          ) : model ? (
            <BoxGeometry
              text={text}
              ref={sphereRef}
              heading={heading}
              buttonText={buttonText}
              headingColor={Heading_Color}
              buttonColor={Button_Color}
              textColor={Text_Color}
              color={Object_Color}
              position={[0, 0, 0]}
              rotateX={rotateX}
              rotateY={rotateY}
              mobile={mobile}
            />
          ) : (
            <Sphere
              text={text}
              ref={sphereRef}
              headingColor={Heading_Color}
              buttonColor={Button_Color}
              createTextTexture={createTextTexture}
              heading={heading}
              textColor={Text_Color}
              position={[0, 0.1, 0]}
              rotateX={rotateX}
              rotateY={rotateY}
              mobile={mobile}
            />
          )}
        </Canvas>
      </Suspense>
    </div>
  );
};

export default GGG;







--------------------------------TaskOne-----------------------------------------------------
import { Decal, Environment, Html, OrbitControls, Plane, Text } from '@react-three/drei';
import { Canvas, useFrame, useLoader, useThree } from '@react-three/fiber';
import React, { useState, useEffect, useRef } from 'react';
import { useSpring } from '@react-spring/three';
import { SketchPicker } from 'react-color';
import { Icon } from '@iconify/react/dist/iconify.js';
import { TextureLoader } from 'three/src/loaders/TextureLoader';
import reactLogo from '/images/images.png';


const degToRad = (degrees) => degrees * (Math.PI / 180);

const curvedText = (text, radius, angle) => {
  const letters = text.split('');
  const segmentAngle = angle / (letters.length - 1);
  return letters.map((letter, i) => {
    const theta = degToRad(-angle / 2 + segmentAngle * i);
    const x = radius * Math.sin(theta);
    const z = radius * Math.cos(theta);
    const rotationY = theta;
    return { letter, position: [x, 0, z], rotation: [0, rotationY, 0] };
  });
};

const BoxGeometry = ({ selectedText, fontSize,planeText, planeHight, textColor = 'black', color = 'orange', position, rotateX, rotateY }) => {
  const radius = 1;
  const angle = 150;
  const letters = curvedText(selectedText, radius, angle);
  const decalTexture = useLoader(TextureLoader, reactLogo);

   // Calculate plane position and rotation
   const planeRadius = radius; // on the sphere surface
   const planeAngle = degToRad(11); // angle on the sphere surface
   const planeX = planeRadius * Math.sin(planeAngle);
   const planeZ = planeRadius * Math.cos(planeAngle);
   const planeRotationX = degToRad(360); // rotate plane to be perpendicular to the sphere surface
   const planeRotationY = planeAngle;
 
  return (
    <mesh position={position} rotation={[rotateX, rotateY, 0]}>
      <sphereGeometry args={[1, 63, 63]} />
      <meshStandardMaterial emissive={color} emissiveIntensity={1} metalness={1} roughness={0} color={color} />
      {letters.map(({ letter, position, rotation }, index) => (
        <Text
          key={index}
          position={position}
          rotation={rotation}
          fontSize={0.1}
          color={textColor}
          anchorX="center"
          anchorY="middle"
        >
          {letter}
        </Text>
      ))}
      <Decal position={[0, 0.5, 0.8]} rotation={[0, 0, 0]} scale={0.5} map={decalTexture} />
        {/* Add a plane with text on it */}
        <Plane position={[planeX, -0.3, planeZ]} rotation={[planeRotationX, planeRotationY, 0]} scale={0.5} args={[1.44, planeHight]}>
        <meshStandardMaterial 
        emissive={color}
         emissiveIntensity={1} 
         metalness={1} roughness={0} color={color} />
        <Text
          fontSize={fontSize}
          color={textColor}
          anchorX="center"      // Align text to the right
          anchorY="middle"        // Align text to the top
          // textAlign="center"    // Align text content to the right within the box
          maxWidth={0.9}      // Ensure text wraps within this width
          lineHeight={1.2}     // Adjust line height if needed
        >
          {planeText}
        </Text>
      </Plane>
    </mesh>
  );
};

const CameraController = ({ cameraPosition }) => {
  const { camera } = useThree();
  const { position } = useSpring({ position: cameraPosition });

  useEffect(() => {
    camera.position.set(...position.get());
    camera.updateProjectionMatrix();
  }, [position, camera]);

  return null;
};

const Controls = ({ isLimitedZoom, currentDistanceRef, initialDistance, zoomLocked }) => {
  const controlsRef = useRef();
  const { camera } = useThree();
  const [initialPositionSet, setInitialPositionSet] = useState(false);
  const zoomLimitsSetRef = useRef(false);

  useEffect(() => {
    if (!initialPositionSet) {
      camera.position.set(0, 0, initialDistance);
      setInitialPositionSet(true);
    }
  }, [camera, initialDistance, initialPositionSet]);

  useEffect(() => {
    if (controlsRef.current) {
      controlsRef.current.enabled = !zoomLocked;
      controlsRef.current.update();
    }
  }, [zoomLocked]);

  useEffect(() => {
    if (controlsRef.current) {
      const currentDistance = currentDistanceRef.current;

      if (isLimitedZoom && !zoomLimitsSetRef.current) {
        if (currentDistance <= 5) {
          controlsRef.current.minDistance = currentDistance - 1;
          controlsRef.current.maxDistance = currentDistance + 1.99;
        } else {
          controlsRef.current.minDistance = currentDistance - 5;
          controlsRef.current.maxDistance = currentDistance + 5;
        }
        zoomLimitsSetRef.current = true;
        console.log(`Min Distance: ${controlsRef.current.minDistance}, Max Distance: ${controlsRef.current.maxDistance}`);
      } else if (!isLimitedZoom) {
        controlsRef.current.minDistance = 2;
        controlsRef.current.maxDistance = 45;
        zoomLimitsSetRef.current = false;
        console.log(`Zoom limits reset: Min Distance: ${controlsRef.current.minDistance}, Max Distance: ${controlsRef.current.maxDistance}`);
      } 

      controlsRef.current.update();
    }
  }, [isLimitedZoom]);

  useFrame(() => {
    if (controlsRef.current) {
      const currentDistance = controlsRef.current.object.position.distanceTo(controlsRef.current.target);
      currentDistanceRef.current = currentDistance;
    }
  });

  return <OrbitControls ref={controlsRef} enableZoom />;
};

const TaskOne = () => {
  const [cameraPosition, setCameraPosition] = useState([0, 0, 3]);
  const [selectedText, setSelectedText] = useState('The world is round and you can meet any one any time');
  const [fontSize, setFontSize] = useState(0.1);
  const [planeHight, setplaneHight] = useState(0.99);
  const [planeText, setPlaneText] = useState('This is for Plane Text');
  const [color, setColor] = useState('#390A63');
  const [textColor, setTextColor] = useState('#FFFFFF');
  const [rotateX, setRotateX] = useState(0);
  const [rotateY, setRotateY] = useState(0);
  const [envPreset, setEnvPreset] = useState('dawn');
  const rotateIntervalRef = useRef(null);
  const [zoomLocked, setZoomLocked] = useState(false);
  const [isLimitedZoom, setIsLimitedZoom] = useState(false);
  const currentDistanceRef = useRef(3); // Default initial distance
  const initialDistance = 3; // Dynamic initial distance

  const startRotation = (direction) => {
    if (rotateIntervalRef.current) {
      clearInterval(rotateIntervalRef.current);
    }

    rotateIntervalRef.current = setInterval(() => {
      switch (direction) {
        case 'left':
          setRotateY((prevRotateY) => prevRotateY - degToRad(1));
          break;
        case 'right':
          setRotateY((prevRotateY) => prevRotateY + degToRad(1));
          break;
        case 'up':
          setRotateX((prevRotateX) => prevRotateX - degToRad(1));
          break;
        case 'down':
          setRotateX((prevRotateX) => prevRotateX + degToRad(1));
          break;
        default:
          break;
      }
    }, 40);
  };

  const stopRotation = () => {
    if (rotateIntervalRef.current) {
      clearInterval(rotateIntervalRef.current);
    }
  };

  const handleTextColorChange = (color) => {
    setTextColor(color.hex);
  };

  const handleColorChange = (color) => {
    setColor(color.hex);
  };

  const handleEnvPresetChange = (e) => {
    setEnvPreset(e.target.value);
  };

  const handleFontSizeChange = (e) => {
    const value = e.target.value;
    if (value === "0.1") {
      setFontSize(0.1);
      setplaneHight(0.99);
    } else if (value === "0.2") {
      setFontSize(0.2);
      setplaneHight(2.66);
    } else if (value === "0.3") {
      setFontSize(0.3);
      setplaneHight(5.66);
    }
  };

  const handleTextChange = (e) => {
    setSelectedText(e.target.value);
  };
  const toggleZoomLock = () => {
    setZoomLocked((prev) => !prev);
  };
  const handlePlaneTextChange = (e) => {
    setPlaneText(e.target.value);
  };

  const toggleLimitedZoom = () => {
    setIsLimitedZoom((prev) => !prev);
  };

  return (
    <div className="h-screen w-screen relative">
      <Canvas camera={{ position: [0, 0, 0.1], fov: 10 }}>
      <BoxGeometry
          selectedText={selectedText}
          fontSize={fontSize}
          planeText={planeText}
          planeHight={planeHight}
          textColor={textColor}
          color={color}
          position={[0, 0, 0]}
          rotateX={rotateX}
          rotateY={rotateY}
        />
        <CameraController cameraPosition={cameraPosition} />
        <Environment preset={envPreset} background={false} />
        <color attach="background" args={['#64748b']} />
        <Controls 
          isLimitedZoom={isLimitedZoom}
          currentDistanceRef={currentDistanceRef}
          initialDistance={initialDistance}
          zoomLocked={zoomLocked}
        />
        
        {/* <BoxGeometry text={Text} textColor={textColor} color={color} position={[0, 0.1, 0]} rotateX={rotateX} rotateY={rotateY} /> */}
        <Html>
          <div className='flex space-x-2 absolute bottom-[25rem] left-[550px] transform -translate-x-1/2'>
            
            <div>

              <button
                onMouseDown={() => startRotation('up')}
                onMouseUp={stopRotation}
                onMouseLeave={stopRotation}
                className="relative overflow-hidden rounded-lg h-12 group hover:shadow-lg hover:scale-105 transition duration-500 before:absolute before:inset-0 before:rounded-lg before:bg-gradient-to-br before:from-pink-400 before:via-purple-400 before:to-indigo-400"
              >
                <span className="relative flex items-center text-white font-bold px-4 py-2">Up</span>
              </button>
            </div>
            <button
              onMouseDown={() => startRotation('left')}
              onMouseUp={stopRotation}
              onMouseLeave={stopRotation}
              className="relative overflow-hidden rounded-lg h-12 group hover:shadow-lg hover:scale-105 transition duration-500 before:absolute before:inset-0 before:rounded-lg before:bg-gradient-to-br before:from-pink-400 before:via-purple-400 before:to-indigo-400"
            >
              <span className="relative flex items-center text-white font-bold px-4 py-2">Left</span>
            </button>
            <button
              onMouseDown={() => startRotation('down')}
              onMouseUp={stopRotation}
              onMouseLeave={stopRotation}
              className="relative overflow-hidden rounded-lg h-12 group hover:shadow-lg hover:scale-105 transition duration-500 before:absolute before:inset-0 before:rounded-lg before:bg-gradient-to-br before:from-pink-400 before:via-purple-400 before:to-indigo-400"
            >
              <span className="relative flex items-center text-white font-bold px-4 py-2">Down</span>
            </button>
            <button
              onMouseDown={() => startRotation('right')}
              onMouseUp={stopRotation}
              onMouseLeave={stopRotation}
              className="relative overflow-hidden rounded-lg h-12 group hover:shadow-lg hover:scale-105 transition duration-500 before:absolute before:inset-0 before:rounded-lg before:bg-gradient-to-br before:from-pink-400 before:via-purple-400 before:to-indigo-400"
            >
              <span className="relative flex items-center text-white font-bold px-4 py-2">Right</span>
            </button>
          </div>
          
          <div className='flex items-center right-24 bottom-[25rem] space-x-8 absolute transform -translate-x-1/2 p-4 rounded'>
            <div className="relative group">
              <button className="relative overflow-hidden rounded-lg h-12 group hover:shadow-lg hover:scale-105 transition duration-500 before:absolute before:inset-0 before:rounded-lg before:bg-gradient-to-br before:from-pink-400 before:via-purple-400 before:to-indigo-400">
                <span className="relative flex items-center text-white  font-bold px-4 py-2">Color <Icon className='mx-1' icon="pepicons-print:color-picker" /></span>
              </button>
              <div className="absolute z-10 hidden group-hover:block  p-2 bg-white border border-gray-300 rounded shadow-lg">
                <SketchPicker color={color} onChangeComplete={handleColorChange} />
              </div>
            </div>
            <div className="relative group">
              <button className="relative overflow-hidden rounded-lg h-12 group hover:shadow-lg hover:scale-105 transition duration-500 before:absolute before:inset-0 before:rounded-lg before:bg-gradient-to-br before:from-pink-400 before:via-purple-400 before:to-indigo-400">
                <span className="relative flex items-center text-white font-bold px-4 py-2">Text <Icon className='mx-1' icon="pepicons-print:color-picker" /></span>
              </button>
              <div className="absolute z-10 hidden group-hover:block mt-0 bg-white border border-gray-300 rounded shadow-lg">
                <SketchPicker color={textColor} onChangeComplete={handleTextColorChange} />
              </div>
            </div>
            <select value={envPreset} onChange={handleEnvPresetChange} className="inline-flex mt-2 p-2 border border-slate-300 rounded focus:outline-none focus:ring-1 focus:ring-slate-300">
              <option value="city">City</option>
              <option value="sunset">Sunset</option>
              <option value="dawn">Dawn</option>
              <option value="night">Night</option>
              <option value="forest">Forest</option>
              <option value="apartment">Apartment</option>
              <option value="studio">Studio</option>
              <option value="warehouse">Warehouse</option>
              <option value="park">Park</option>
              <option value="lobby">Lobby</option>
            </select>
            {/* <button
              onClick={toggleZoomLock}
              className="relative overflow-hidden rounded-lg h-12 group hover:shadow-lg hover:scale-105 transition duration-500 before:absolute before:inset-0 before:rounded-lg before:bg-gradient-to-br before:from-pink-400 before:via-purple-400 before:to-indigo-400"
            >
              <span className="relative flex items-center text-white font-bold px-4 py-2">
              {zoomLocked ? <Icon height={"30px"} icon="material-symbols:lock" /> : <Icon height={"30px"} icon="bi:unlock-fill" />}
              </span>
            </button> */}
            <button
              onClick={toggleLimitedZoom}
              className="relative overflow-hidden rounded-lg h-12 group hover:shadow-lg hover:scale-105 transition duration-500 before:absolute before:inset-0 before:rounded-lg before:bg-gradient-to-br before:from-pink-400 before:via-purple-400 before:to-indigo-400"
            >
              <span className="relative flex items-center text-white font-bold w-16  justify-center ">
              {isLimitedZoom ? <Icon height={"30px"} icon="material-symbols:lock" /> : <Icon height={"30px"} icon="bi:unlock-fill" />}
              </span>
            </button>
         

            
          </div>
          <div className='relative right-[45.5rem] bottom-[10rem]'>
               <label className='text-white'>
          Select font size:
          <select
            className="border p-1 rounded w-full mb-10 text-black"
            value={fontSize}
            onChange={handleFontSizeChange}
          >
            <option value="0.1">Small</option>
            <option value="0.2">Medium</option>
            <option value="0.3">Large</option>
          </select>
        </label>
            
              
        <div className=" top-4 w-48 left-4 bg-white bg-opacity-75 p-4 rounded shadow-md">
        <label>
          Enter text:
          <textarea
            className="border p-1 rounded w-full"
            value={planeText} onChange={handlePlaneTextChange}
            rows={3}
          />
        </label>
            </div>
        </div>
        </Html>
      </Canvas>
    </div>
  );
};

export default TaskOne;


-----------------------------Orignal Task 2 ---------------------------------

import { Decal, Environment, Html, OrbitControls, Text} from '@react-three/drei';
import { Canvas, useFrame, useLoader, useThree } from '@react-three/fiber';
import React, { useState, useEffect, useRef } from 'react';
import { useSpring } from '@react-spring/three';
import { TextureLoader, CanvasTexture, LinearFilter } from 'three';
import { BlockPicker} from 'react-color';
import { Icon } from '@iconify/react/dist/iconify.js';
// import { TextureLoader } from 'three/src/loaders/TextureLoader';
// import reactLogo from '/images.png';
// import { texture } from 'three/examples/jsm/nodes/Nodes.js';



const degToRad = (degrees) => degrees * (Math.PI / 180);

const createTextTexture = (text, heading, buttonText, headingColor, textColor, buttonColor) => {
  const canvas = document.createElement('canvas');
  canvas.width = 4300; // Adjust this to control the resolution
  canvas.height = 2080; // Adjust this to control the resolution
  const context = canvas.getContext('2d');

  // Background
  context.fillStyle = 'white';
  context.fillRect(0, 0, canvas.width, canvas.height);

  // Heading
  context.font = 'bold 150px Arial';
  context.fillStyle = headingColor;
  context.textAlign = 'center';
  context.textBaseline = 'middle';
  context.lineJoin = 'round';
  context.miterLimit = 2;
  context.fillText(heading, canvas.width / 2, 200);

  // Button
  const buttonWidth = 800; // Adjusted width
  const buttonHeight = 200; // Adjusted height
  const buttonX = (canvas.width / 2) - (buttonWidth / 2);
  const buttonY = 400; // Adjusted y-position

  context.fillStyle = buttonColor;
  context.fillRect(buttonX, buttonY, buttonWidth, buttonHeight);
  context.font = 'bold 80px Arial'; // Larger font size
  context.fillStyle = textColor;
  context.fillText(buttonText, canvas.width / 2, buttonY + (buttonHeight / 2));

  // Paragraph
  context.font = '50px Arial'; // Larger font size
  context.fillStyle = buttonColor;
  context.textAlign = 'center';

  const words = text.split(' ');
  let line = '';
  let y = buttonY + buttonHeight + 100; // Adjusted y-position
  const lineHeight = 100; // Increased line height

  words.forEach((word) => {
    const testLine = `${line}${word} `;
    const metrics = context.measureText(testLine);
    const testWidth = metrics.width;
    if (testWidth > canvas.width - 40 && line !== '') {
      context.fillText(line, canvas.width / 2, y);
      line = `${word} `;
      y += lineHeight;
    } else {
      line = testLine;
    }
  });
  context.fillText(line, canvas.width / 2, y);

  const texture = new CanvasTexture(canvas);
  texture.anisotropy = 16; // Increase anisotropy for better quality at an angle
  texture.minFilter = LinearFilter; // Use linear filter for smoother appearance
  texture.magFilter = LinearFilter; // Use linear filter for smoother appearance
  texture.generateMipmaps = false; // Disable mipmaps if text appears blurry

  return texture;
};


const BoxGeometry = ({ text,mobile, heading, buttonText, headingColor, buttonColor, textColor = 'black', color = 'orange', position, rotateX, rotateY }) => {
 
//   const decalTexture = useLoader(TextureLoader, reactLogo);
const texture = createTextTexture(text, heading, buttonText, headingColor,textColor, buttonColor);

  return (
    <mesh position={position}
     rotation={[rotateX, rotateY, 0]} scale={mobile ? 0.70 : 1}
     >

      <sphereGeometry args={[1, 63, 63]} />
      <meshStandardMaterial
      //  emissive={color}
      //  emissiveIntensity={1}
        metalness={0} roughness={0} opacity={1} color={color} map={texture} />
      {/* {letters.map(({ letter, position, rotation }, index) => (
        <Text
          key={index}
          position={position}
          rotation={rotation}
          fontSize={0.1}
          color={textColor}
          anchorX="center"
          anchorY="middle"
        >
          {letter}
        </Text>
      ))}
      <Decal position={[0, 0.5, 0.8]} rotation={[0, 0, 0]} scale={0.5} map={decalTexture} /> */}
    </mesh>
  );
};

const CameraController = ({ cameraPosition }) => {
  const { camera } = useThree();
  const { position } = useSpring({ position: cameraPosition });

  useEffect(() => {
    camera.position.set(...position.get());
    camera.updateProjectionMatrix();
  }, [position, camera]);

  return null;
};

const Controls = ({ isLimitedZoom, currentDistanceRef, initialDistance, zoomLocked }) => {
  const controlsRef = useRef();
  const { camera } = useThree();
  const [initialPositionSet, setInitialPositionSet] = useState(false);
  const zoomLimitsSetRef = useRef(false);

  useEffect(() => {
    if (!initialPositionSet) {
      camera.position.set(0, 0, initialDistance);
      setInitialPositionSet(true);
    }
  }, [camera, initialDistance, initialPositionSet]);

  useEffect(() => {
    if (controlsRef.current) {
      controlsRef.current.enabled = !zoomLocked;
      controlsRef.current.update();
    }
  }, [zoomLocked]);

  useEffect(() => {
    if (controlsRef.current) {
      const currentDistance = currentDistanceRef.current;

      if (isLimitedZoom && !zoomLimitsSetRef.current) {
        if (currentDistance <= 5) {
          controlsRef.current.minDistance = currentDistance - 1;
          controlsRef.current.maxDistance = currentDistance + 1.10;
        } else {
          controlsRef.current.minDistance = currentDistance - 5;
          controlsRef.current.maxDistance = currentDistance + 5;
        }
        zoomLimitsSetRef.current = true;
        console.log(`Min Distance: ${controlsRef.current.minDistance}, Max Distance: ${controlsRef.current.maxDistance}`);
      } else if (!isLimitedZoom) {
        controlsRef.current.minDistance = 2;
        controlsRef.current.maxDistance = 45;
        zoomLimitsSetRef.current = false;
        console.log(`Zoom limits reset: Min Distance: ${controlsRef.current.minDistance}, Max Distance: ${controlsRef.current.maxDistance}`);
      } 

      controlsRef.current.update();
    }
  }, [isLimitedZoom]);
  useFrame(() => {
    if (controlsRef.current) {
      const currentDistance = controlsRef.current.object.position.distanceTo(controlsRef.current.target);
      currentDistanceRef.current = currentDistance;
    }
  });

  return <OrbitControls ref={controlsRef} enableZoom />;
};

const GGG= () => {
  const [cameraPosition, setCameraPosition] = useState([0, 0, 3]);
  const [buttonText, setButtonText] = useState('Click Me');
  const [heading, setHeading] = useState('Global Text');
  const [text, setText] = useState('TLorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.  Lorem ipsum dolor sit amet consectetur adipisicing elit. Possimus aperiam hic sapiente, quam doloribus eos assumenda soluta iusto fugit perspiciatis quo, vitae vel sed. Harum eveniet sequi ut laudantium iure. Lorem ipsum dolor sit amet consectetur adipisicing elit. Possimus aperiam hic sapiente, quam doloribus eos assumenda soluta iusto fugit perspiciatis quo, vitae vel sed. Harum eveniet sequi ut laudantium iure. Lorem ipsum dolor sit amet consectetur adipisicing elit. Possimus aperiam hic sapiente, quam doloribus eos assumenda soluta iusto fugit perspiciatis quo, vitae vel sed. Harum eveniet sequi ut laudantium iure. Lorem ipsum dolor sit amet consectetur adipisicing elit. Possimus aperiam hic sapiente, quam doloribus eos assumenda soluta iusto fugit perspiciatis quo, vitae vel sed. Harum eveniet sequi ut laudantium iure. Lorem ipsum  Lorem ipsum dolor sit  perspiciatis quo, vitae vel sed. Harum eveniet sequi ut laudantium iure. Lorem ipsum dolor sit amet consectetur adipisicing elit. Possimus aperiam hic sapiente, quam doloribus eos assumenda soluta iusto fugit perspiciatis quo, vitae vel sed. Harum eveniet sequi ut laudantium iure. Lorem ipsum  Lorem ipsum dolor sit  perspiciatis quo, vitae vel sed. Harum eveniet sequi ut laudantium iure. Lorem ipsum dolor sit amet consectetur adipisicing elit. Possimus aperiam hic sapiente, quam doloribus eos assumenda soluta iusto fugit perspiciatis quo, vitae vel sed. Harum eveniet sequi ut laudantium iure. Lorem ipsum  Lorem ipsum dolor sit  perspiciatis quo, vitae vel sed. Harum eveniet sequi ut laudantium iure. Lorem ipsum dolor sit amet consectetur adipisicing elit. Possimus aperiam hic sapiente, quam doloribus eos assumenda soluta iusto fugit perspiciatis quo, vitae vel sed. Harum eveniet sequi ut laudantium iure. Lorem ipsum  Lorem ipsum dolor sit  perspiciatis quo, vitae vel sed. Harum eveniet sequi ut laudantium iure. Lorem ipsum dolor sit amet consectetur adipisicing elit. Possimus aperiam hic sapiente, quam doloribus eos assumenda soluta iusto fugit perspiciatis quo, vitae vel sed. Harum eveniet sequi ut laudantium iure. Lorem ipsum  Lorem ipsum dolor sit amet consectetur adipisicing elit. Possimus aperiam hic sapiente, quam doloribus eos assumenda soluta iusto fugit perspicia Lorem ipsum dolor sit amet consectetur adipisicing elit. Possimus aperiam hic sapiente, quam doloribus eos assumenda soluta iusto fugit perspiciatis quo, vitae vel sed. Harum eveniet sequi ut laudantium iure. Lorem ipsum dolor sit amet consectetur adipisicing elit. Possimus aperiam hic sapiente, quam doloribus eos assumenda soluta iusto fugit perspiciatis quo, vitae vel sed. Harum eveniet sequi ut laudantium iure. Lorem ipsum dolor sit amet consectetur adipisicing elit. Possimus aperiam hic sapiente, quam doloribus eos assumenda soluta iusto fugit perspiciatis quo, vitae vel sed. Harum eveniet sequi ut laudantium iure. Lorem ipsum dolor sit amet consectetur adipisicing elit. Possimus aperiam hic sapiente, quam doloribus eos assumenda soluta iusto fugit perspiciatis quo, vitae vel sed. Harum eveniet sequi ut laudantium iure.a soluta iusto fugit perspiciatis quo, vitae vel sed. Harum eveniet sequi ut laudantium iure. dolor sit amet consectetur adipisicing elit. Possimus aperiam hic sapiente, quam doloribus eos assumenda soluta iusto fugit perspiciatis quo, vitae vel sed. Harum eveniet sequi ut laudantium iure');
  const [color, setColor] = useState('#754280');
  const [textColor, setTextColor] = useState('#000000');
  const [headingColor, setHeadingColor] = useState('#000000'); // Initial color for heading
const [buttonColor, setButtonColor] = useState('#ff0000'); // Initial color for button

  const [rotateX, setRotateX] = useState(0);
  const [rotateY, setRotateY] = useState(0);
  const [envPreset, setEnvPreset] = useState('dawn');
  const rotateIntervalRef = useRef(null);
  const [zoomLocked, setZoomLocked] = useState(false);
  const [isLimitedZoom, setIsLimitedZoom] = useState(false);
  const currentDistanceRef = useRef(3); // Default initial distance
  const initialDistance = 3; // Dynamic initial distance
  const [environmentActive, setEnvironmentActive] = useState(true);
  const [mobile, setmobile] = useState(false);
  useEffect(() => {
    const mediaQuery = window.matchMedia("(max-width:500px)");
    setmobile(mediaQuery.matches);

    const handleMediaQuaryChange = (event) => {
      setmobile(event.matches);
      console.log('Media query matched:', event.matches); // Debug log
      console.log('Current mobile state:', mobile);  
      
      
    };
    mediaQuery.addEventListener("change", handleMediaQuaryChange);

    return () => {
      mediaQuery.removeEventListener("change", handleMediaQuaryChange);
    };
  }, []);

  useEffect(() => {
    console.log('Updated mobile state:', mobile);
  }, [mobile]);
  
  const startRotation = (direction) => {
    if (rotateIntervalRef.current) {
      clearInterval(rotateIntervalRef.current);
    }

    rotateIntervalRef.current = setInterval(() => {
      switch (direction) {
        case 'left':
          setRotateY((prevRotateY) => prevRotateY - degToRad(1));
          break;
        case 'right':
          setRotateY((prevRotateY) => prevRotateY + degToRad(1));
          break;
        case 'up':
          setRotateX((prevRotateX) => prevRotateX - degToRad(1));
          break;
        case 'down':
          setRotateX((prevRotateX) => prevRotateX + degToRad(1));
          break;
        default:
          break;
      }
    }, 40);
  };
  const handleHeadingColorChange = (color) => {
    setHeadingColor(color.hex);
};

const handleButtonColorChange = (color) => {
    setButtonColor(color.hex);
};

  const stopRotation = () => {
    if (rotateIntervalRef.current) {
      clearInterval(rotateIntervalRef.current);
    }
  };

  const handleTextColorChange = (color) => {
    setTextColor(color.hex);
  };

  const handleColorChange = (color) => {
    setColor(color.hex);
  };

  const handleEnvPresetChange = (e) => {
    if (e.target.value === 'default') {
      setEnvironmentActive(!environmentActive);
    } else {
      setEnvPreset(e.target.value);
    }
  };

  const toggleZoomLock = () => {
    setZoomLocked((prev) => !prev);
  };

  const toggleLimitedZoom = () => {
    setIsLimitedZoom((prev) => !prev);
  };

  return (
    <div className="h-screen w-screen relative">
      <Canvas gl={{antialias:true}} camera={{ position: [0, 0, 0.1], fov: 10, near: 0.1, far: 1000}}>
      <ambientLight intensity={1.5} />
      {/* <directionalLight position={[5, 5, 5]} intensity={1} /> */}
        <CameraController cameraPosition={cameraPosition} />
        {environmentActive && <Environment preset={envPreset} background={false} />}
        <color attach="background" args={['#64748b']} />
        <Controls 
          isLimitedZoom={isLimitedZoom}
          currentDistanceRef={currentDistanceRef}
          initialDistance={initialDistance}
          zoomLocked={zoomLocked}
        />
        <BoxGeometry text={text} headingColor={headingColor}
  buttonColor={buttonColor} buttonText={buttonText} mobile={mobile} heading={heading}  textColor={textColor} color={color} position={[0, 0.1, 0]} rotateX={rotateX} rotateY={rotateY} />
  {/* console.log("is mobile":mobile) */}
 
        <Html>
          <div className='flex max-sm:left-0 max-sm:-top-[135px] max-sm:gap-0 max-sm: space-x-1 absolute bottom-48 left-[550px] transform -translate-x-1/2'>
            <div>
              <button
                onMouseDown={() => startRotation('up')}
                onMouseUp={stopRotation}
                onMouseLeave={stopRotation}
                className="relative overflow-hidden rounded-lgmax-sm:rounded-none max-sm:hidden h-12 max-sm:h-5 group hover:shadow-lg hover:scale-105 transition duration-500 before:absolute  before:inset-0 before:rounded-lg before:bg-gradient-to-br before:from-pink-400 before:via-purple-400 before:to-indigo-400"
              >
                <span className="relative  flex items-center text-white font-bold
     max-sm:text-sm px-4 max-sm:px-1 py-2 max-sm:py-0">Up</span>
              </button>
            </div>
            <button
              onMouseDown={() => startRotation('left')}
              onMouseUp={stopRotation}
              onMouseLeave={stopRotation}
              className="relative overflow-hidden rounded-lgmax-sm:rounded-none max-sm:hidden  h-12 max-sm:h-5 group hover:shadow-lg hover:scale-105 transition duration-500 before:absolute  before:inset-0 before:rounded-lg before:bg-gradient-to-br before:from-pink-400 before:via-purple-400 before:to-indigo-400"
            >
              <span className="relative flex items-center text-white font-bold
     max-sm:text-sm px-4 max-sm:px-1 py-2 max-sm:py-0">Left</span>
            </button>
            <button
              onMouseDown={() => startRotation('down')}
              onMouseUp={stopRotation}
              onMouseLeave={stopRotation}
              className="relative overflow-hidden rounded-lgmax-sm:rounded-none max-sm:hidden  h-12 max-sm:h-5 group hover:shadow-lg hover:scale-105 transition duration-500 before:absolute  before:inset-0 before:rounded-lg before:bg-gradient-to-br before:from-pink-400 before:via-purple-400 before:to-indigo-400"
            >
              <span className="relative flex items-center text-white font-bold
     max-sm:text-sm px-4 max-sm:px-1 py-2 max-sm:py-0">Down</span>
            </button>
            <button
              onMouseDown={() => startRotation('right')}
              onMouseUp={stopRotation}
              onMouseLeave={stopRotation}
              className="relative overflow-hidden rounded-lgmax-sm:rounded-none max-sm:hidden  h-12 max-sm:h-5 group hover:shadow-lg hover:scale-105 transition duration-500 before:absolute  before:inset-0 before:rounded-lg before:bg-gradient-to-br before:from-pink-400 before:via-purple-400 before:to-indigo-400"
            >
              <span className="relative flex items-center text-white font-bold
     max-sm:text-sm px-4 max-sm:px-1 py-2 max-sm:py-0">Right</span>
            </button>
          </div>
          <div className='flex max-sm:flex-col max-sm:justify-center max-sm:-right-[135px] max-sm:gap-2 max-sm:-bottom-20 items-center bottom-48 -right-[429px] space-x-8 absolute transform -translate-x-1/2 p-4 rounded'>
            <div className="relative group">
              <button className="relative overflow-hidden rounded-lgmax-sm:rounded-none max-sm:hidden  h-12 max-sm:h-5 group hover:shadow-lg hover:scale-105 transition duration-500 before:absolute  before:inset-0 before:rounded-lg before:bg-gradient-to-br before:from-pink-400 before:via-purple-400 before:to-indigo-400">
                <span className="relative flex items-center text-white font-bold
     max-sm:text-sm px-4 max-sm:px-1 py-2 max-sm:py-0">Color <Icon className='mx-1' icon="pepicons-print:color-picker" /></span>
              </button>
              <div className="absolute z-10 hidden group-hover:block  p-2 bg-white border border-gray-300 rounded shadow-lg">
                <BlockPicker  className="custom-sketch-picker" 
        //         styles={{
        //   default: {
        //     picker: {
        //       width: '100px', 
        //       height: '300px', 
        //     },
        //   },
        // }} 
        color={color} onChangeComplete={handleColorChange} />
              </div>
            </div>
            <div className="relative group">
  <button className="relative overflow-hidden rounded-lgmax-sm:rounded-none max-sm:hidden  h-12 max-sm:h-5 group hover:shadow-lg hover:scale-105 transition duration-500 before:absolute  before:inset-0 before:rounded-lg before:bg-gradient-to-br before:from-pink-400 before:via-purple-400 before:to-indigo-400">
    <span className="relative flex items-center text-white font-bold
     max-sm:text-sm px-4 max-sm:px-1 py-2 max-sm:py-0">
      Text <Icon className='mx-1' icon="pepicons-print:color-picker" />
    </span>
  </button>
  <div className="absolute z-10 hidden group-hover:block  p-2 bg-white border border-gray-300 rounded shadow-lg">
    <BlockPicker className="custom-sketch-picker" color={headingColor} onChangeComplete={handleHeadingColorChange} />
  </div>
</div>
{/* <label className="relative inline-flex items-center cursor-pointer">
          <input
            type="checkbox"
            checked={environmentActive}
            onChange={() => setEnvironmentActive(!environmentActive)}
            className="sr-only peer"
          />
          <div className="w-11 h-6 bg-gray-200 rounded-full  peer-checked:bg-indigo-600 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all dark:border-gray-600"></div>
          
        </label>  */}
<div className="relative group">
  <button className="relative overflow-hidden rounded-lgmax-sm:rounded-none max-sm:hidden  h-12 max-sm:h-5 group hover:shadow-lg hover:scale-105 transition duration-500 before:absolute  before:inset-0 before:rounded-lg before:bg-gradient-to-br before:from-pink-400 before:via-purple-400 before:to-indigo-400">
    <span className="relative flex items-center text-white font-bold
     max-sm:text-sm px-4 max-sm:px-1 py-2 max-sm:py-0">
      Button <Icon className='mx-1' icon="pepicons-print:color-picker" />
    </span>
  </button>
  <div className="absolute z-10 hidden group-hover:block  p-2 max-sm:p-0 bg-white border border-gray-300 rounded shadow-lg">
    <BlockPicker className="custom-sketch-picker" color={buttonColor} onChangeComplete={handleButtonColorChange} />
  </div>
</div>


            {/* <div className="relative group">
              <button className="relative overflow-hidden rounded-lg h-12 group hover:shadow-lg hover:scale-105 transition duration-500 before:absolute before:inset-0 before:rounded-lg before:bg-gradient-to-br before:from-pink-400 before:via-purple-400 before:to-indigo-400">
                <span className="relative flex items-center text-white font-bold px-4 py-2">Text <Icon className='mx-1' icon="pepicons-print:color-picker" /></span>
              </button>
              <div className="absolute z-10 hidden group-hover:block mt-0 bg-white border border-gray-300 rounded shadow-lg">
                <BlockPicker color={textColor} onChangeComplete={handleTextColorChange} />
              </div>
            </div> */}
            <select value={envPreset} onChange={handleEnvPresetChange} className="inline-flex mt-2 p-2 w-28 max-sm:hidden border border-slate-300 rounded focus:outline-none focus:ring-1 focus:ring-slate-300">
              <option value="default">Default</option>
              <option value="city">City</option>
              <option value="sunset">Sunset</option>
              <option value="dawn">Dawn</option>
              <option value="night">Night</option>
              <option value="forest">Forest</option>
              <option value="apartment">Apartment</option>
              <option value="studio">Studio</option>
              <option value="warehouse">Warehouse</option>
              <option value="park">Park</option>
              <option value="lobby">Lobby</option>
            </select>
                 {/* <button
              onClick={toggleZoomLock}
              className="relative overflow-hidden rounded-lg h-12 group hover:shadow-lg hover:scale-105 transition duration-500 before:absolute before:inset-0 before:rounded-lg before:bg-gradient-to-br before:from-pink-400 before:via-purple-400 before:to-indigo-400"
            >
              <span className="relative flex items-center text-white font-bold px-4 py-2">
              {zoomLocked ? <Icon height={"30px"} icon="material-symbols:lock" /> : <Icon height={"30px"} icon="bi:unlock-fill" />}
              </span>
            </button> */}
            <button
              onClick={toggleLimitedZoom}
              className="relative overflow-hidden rounded-lgmax-sm:rounded-none max-sm:hidden  h-12 max-sm:h-5 group hover:shadow-lg hover:scale-105 transition duration-500 before:absolute  before:inset-0 before:rounded-lg before:bg-gradient-to-br before:from-pink-400 before:via-purple-400 before:to-indigo-400"
            >
              <span className="relative flex items-center text-white font-bold
     max-sm:font-light max-sm:text-sm px-4 max-sm:px-1 py-2 max-sm:py-0">
              {isLimitedZoom ? <Icon className='h-[30px] max-sm:h-[10px]'  icon="material-symbols:lock" /> : <Icon className='h-[30px] max-sm:h-[10px]' icon="bi:unlock-fill" />}
              </span>
            </button>
          </div>
        </Html>
      </Canvas>
    </div>
  );
};

export default GGG;
